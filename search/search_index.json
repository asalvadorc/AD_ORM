{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Eines de mapatge Objecte-Relacional"},{"location":"10__consultes_dactualitzaci/","text":"10 - Consultes d'actualitzaci\u00f3 Aquesta pregunta no t\u00e9 tanta import\u00e0ncia com les altres, ja que actualitzacions ja sab\u00edem fer amb els m\u00e8todes persist() , remove() i mege() de la sessi\u00f3 (o els seus equivalents ja deprecated save() , delete() i update() ) Pr\u00e0cticament l'\u00fanica utilitat ser\u00e0 fer actualitzacions massives, que afecten a m\u00e9s d'una fila (millor dit, m\u00e9s d'un objecte). HQL tamb\u00e9 permet fer-les. Lamentablement, aquestes sent\u00e8ncies HQL no tornen cap classe, i per tant no podem posar res v\u00e0lid en el segon par\u00e0metre de createQuery() . Per tant, per a aquest tipus de sent\u00e8ncia ens veurem obligats a utilitzar la versi\u00f3 deprecated de createQuery() , la que no li posem un segon par\u00e0metre Mirem la seua sintaxi: DELETE DELETE [FROM] NomEntitat [WHERE condici\u00f3] Esborrar\u00e0 tots els objecte que acomplesquen la condici\u00f3. Observeu que: FROM \u00e9s opcional La cl\u00e0usula WHERE \u00e9s opcional. Si no es posa s'esborraran tots els objectes. En el FROM nom\u00e9s es pot posar una entitat. No val a posar m\u00e9s d'una ni reunions ni res. S\u00ed que es podran posar subconsultes en la cl\u00e0usula WHERE, i en les consultes s\u00ed que es pot fer el que es vulga (reunions, ...). Per a executar la consulta s'utilitzar\u00e0 el m\u00e8tode Query. executeUpdate() (en compte de Query. list() per exemple). Aquest m\u00e8tode torna un enter que ser\u00e0 el n\u00famero de files (objectes) esborrades. I recordeu que s'ha de confirmar la transacci\u00f3 per a que tinguen efecte els canvis. Ac\u00ed tenim un exemple, al qual li hem aplicat ROLLBACK al final, per a no fer efectiu l'esborrat. Per\u00f2 s\u00ed que diu quantes files \"s'esborrarien\". El seg\u00fcent exemple \"esborraria\" els Instituts de la prov\u00edncia de Castell\u00f3, que s\u00f3n els que el seu codi comen\u00e7a per 12, i es diu quants serien els afectats, per\u00f2 despr\u00e9s es rebutgen els canvis en fer rollback() . Copieu el seg\u00fcent codi al fitxer Exemple_51_EsborratMassiu.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val files = sessio.createQuery(\"delete Institut where codi like '12%'\").executeUpdate() println(\"S'han esborrat \" + files + \" files.\") t.rollback() sessio.close() } Ens dir\u00e0 que s'han esborrat 52 files, per\u00f2 despr\u00e9s no les esborrar\u00e0 de veritat. UPDATE UPDATE [FROM] NomEntitat SET propietat = valor [, propietat2 = valor2, ...] [ WHERE condicio ] Les observacions fetes en l'apartat de DELETE tamb\u00e9 valen ac\u00ed. I observeu que podem modificar m\u00e9s d'un camp, separant-los per comes. Ac\u00ed tenim un exemple, en el qual fem tamb\u00e9 rollback() per a deixar les coses com estaven. Copieu el seg\u00fcent codi al fitxer Exemple_52_ModificacioMassiva.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val files = sessio.createQuery(\"update Poblacio set poblacio = poblacio *1.05 where poblacio < 200\").executeUpdate() println(\"S'han modificat \" + files + \" files.\") t.rollback() sessio.close() } INSERT INSERT INTO NomEntitat (llista_propietats) Sent\u00e8ncia_select Ara tindrem els seg\u00fcents condicionants: No \u00e9s v\u00e0lida la sent\u00e8ncia INSERT INTO ... VALUES ... que servia per a introduir una fila donant-li els valors. Si volem fer aix\u00f2, millor utilitzar save() . Per tant nom\u00e9s podrem introduir valors procedents d'una altra taula. La sent\u00e8ncia SELECT pot ser qualsevol sent\u00e8ncia HQL. Nom\u00e9s hem de cuidar que els tipus tornats per la consulta siguen els que espera INSERT (\u00e9s a dir, del mateix tipus que les propietats de la classe associada a la taula). Per a la propietat id , que \u00e9s la que correspon a la clau principal, podem tenir 2 opcions: es pot especificar en la llista de propietats, i aleshores li haurem de proporcionar un valor. es pot ometre, sempre i quan la propietat estiga definida com increment (no assigned ); aix\u00f2 vol dir que es correspon a un camp autoincrementat. Aleshores ser\u00e0 el SGBD qui li assignar\u00e0 el valor Aquest seria un exemple. En ell intentem introduir una nova comarca a partir d'una hipot\u00e8tica taula de comarques noves ( NovesComarques ). No la podrem provar perqu\u00e8 no existeix aquesta taula, millor dit, aquesta classe. L'haur\u00edem de crear, fer-li el mapatge, i posteriorment executar a\u00e7\u00f2. Per tant ho veiem \u00fanicament a mode il\u00b7lustratiu: val t = sessio.beginTransaction() val files = sessio.createQuery(\"insert into Comarca (nomC, provincia) \" \\+ \" select n.nomC, n.provincia from NovesComarques n\").executeUpdate() println(\"S'han introdu\u00eft \" + files + \" files.\") t.rollback() Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"10 - Consultes d'actualitzaci\u00f3"},{"location":"10__consultes_dactualitzaci/#10-consultes-dactualitzacio","text":"Aquesta pregunta no t\u00e9 tanta import\u00e0ncia com les altres, ja que actualitzacions ja sab\u00edem fer amb els m\u00e8todes persist() , remove() i mege() de la sessi\u00f3 (o els seus equivalents ja deprecated save() , delete() i update() ) Pr\u00e0cticament l'\u00fanica utilitat ser\u00e0 fer actualitzacions massives, que afecten a m\u00e9s d'una fila (millor dit, m\u00e9s d'un objecte). HQL tamb\u00e9 permet fer-les. Lamentablement, aquestes sent\u00e8ncies HQL no tornen cap classe, i per tant no podem posar res v\u00e0lid en el segon par\u00e0metre de createQuery() . Per tant, per a aquest tipus de sent\u00e8ncia ens veurem obligats a utilitzar la versi\u00f3 deprecated de createQuery() , la que no li posem un segon par\u00e0metre Mirem la seua sintaxi: DELETE DELETE [FROM] NomEntitat [WHERE condici\u00f3] Esborrar\u00e0 tots els objecte que acomplesquen la condici\u00f3. Observeu que: FROM \u00e9s opcional La cl\u00e0usula WHERE \u00e9s opcional. Si no es posa s'esborraran tots els objectes. En el FROM nom\u00e9s es pot posar una entitat. No val a posar m\u00e9s d'una ni reunions ni res. S\u00ed que es podran posar subconsultes en la cl\u00e0usula WHERE, i en les consultes s\u00ed que es pot fer el que es vulga (reunions, ...). Per a executar la consulta s'utilitzar\u00e0 el m\u00e8tode Query. executeUpdate() (en compte de Query. list() per exemple). Aquest m\u00e8tode torna un enter que ser\u00e0 el n\u00famero de files (objectes) esborrades. I recordeu que s'ha de confirmar la transacci\u00f3 per a que tinguen efecte els canvis. Ac\u00ed tenim un exemple, al qual li hem aplicat ROLLBACK al final, per a no fer efectiu l'esborrat. Per\u00f2 s\u00ed que diu quantes files \"s'esborrarien\". El seg\u00fcent exemple \"esborraria\" els Instituts de la prov\u00edncia de Castell\u00f3, que s\u00f3n els que el seu codi comen\u00e7a per 12, i es diu quants serien els afectats, per\u00f2 despr\u00e9s es rebutgen els canvis en fer rollback() . Copieu el seg\u00fcent codi al fitxer Exemple_51_EsborratMassiu.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val files = sessio.createQuery(\"delete Institut where codi like '12%'\").executeUpdate() println(\"S'han esborrat \" + files + \" files.\") t.rollback() sessio.close() } Ens dir\u00e0 que s'han esborrat 52 files, per\u00f2 despr\u00e9s no les esborrar\u00e0 de veritat. UPDATE UPDATE [FROM] NomEntitat SET propietat = valor [, propietat2 = valor2, ...] [ WHERE condicio ] Les observacions fetes en l'apartat de DELETE tamb\u00e9 valen ac\u00ed. I observeu que podem modificar m\u00e9s d'un camp, separant-los per comes. Ac\u00ed tenim un exemple, en el qual fem tamb\u00e9 rollback() per a deixar les coses com estaven. Copieu el seg\u00fcent codi al fitxer Exemple_52_ModificacioMassiva.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val files = sessio.createQuery(\"update Poblacio set poblacio = poblacio *1.05 where poblacio < 200\").executeUpdate() println(\"S'han modificat \" + files + \" files.\") t.rollback() sessio.close() } INSERT INSERT INTO NomEntitat (llista_propietats) Sent\u00e8ncia_select Ara tindrem els seg\u00fcents condicionants: No \u00e9s v\u00e0lida la sent\u00e8ncia INSERT INTO ... VALUES ... que servia per a introduir una fila donant-li els valors. Si volem fer aix\u00f2, millor utilitzar save() . Per tant nom\u00e9s podrem introduir valors procedents d'una altra taula. La sent\u00e8ncia SELECT pot ser qualsevol sent\u00e8ncia HQL. Nom\u00e9s hem de cuidar que els tipus tornats per la consulta siguen els que espera INSERT (\u00e9s a dir, del mateix tipus que les propietats de la classe associada a la taula). Per a la propietat id , que \u00e9s la que correspon a la clau principal, podem tenir 2 opcions: es pot especificar en la llista de propietats, i aleshores li haurem de proporcionar un valor. es pot ometre, sempre i quan la propietat estiga definida com increment (no assigned ); aix\u00f2 vol dir que es correspon a un camp autoincrementat. Aleshores ser\u00e0 el SGBD qui li assignar\u00e0 el valor Aquest seria un exemple. En ell intentem introduir una nova comarca a partir d'una hipot\u00e8tica taula de comarques noves ( NovesComarques ). No la podrem provar perqu\u00e8 no existeix aquesta taula, millor dit, aquesta classe. L'haur\u00edem de crear, fer-li el mapatge, i posteriorment executar a\u00e7\u00f2. Per tant ho veiem \u00fanicament a mode il\u00b7lustratiu: val t = sessio.beginTransaction() val files = sessio.createQuery(\"insert into Comarca (nomC, provincia) \" \\+ \" select n.nomC, n.provincia from NovesComarques n\").executeUpdate() println(\"S'han introdu\u00eft \" + files + \" files.\") t.rollback() Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"10 - Consultes d'actualitzaci\u00f3"},{"location":"11__resum_del_llenguatge_hql/","text":"11 - Resum del llenguatge HQL Veurem d'una manera molt r\u00e0pida el llenguatge HQL. Sobretot insistirem en les difer\u00e8ncies amb SQL, al qual se sembla molt. La cl\u00e0usula SELECT \u00e9s opcional. Si no la posem equival a agafar totes les propietats (\u00e9s a dir, equivalent a SELECT * de SQL). \u00c9s una operaci\u00f3 molt habitual, ja que d'aquesta manera la llista d'objectes tornats \u00e9s de la classe marcada en el from. Es poden utilitzar \u00e0lies de les classes, posant AS despr\u00e9s de la classe i abans de l'\u00e0lies. Tamb\u00e9 podem prescindir del AS. Si utilitzem \u00e0lies, per a fer refer\u00e8ncia a la classe haurem d'utilitzar sempre l'\u00e0lies. Per exemple FROM Comarques AS c , o senzillament FROM Comarques c . La cl\u00e0usula WHERE \u00e9s opcional. Si no la posem equival a agafar de totes les inst\u00e0ncies de la classe associada (\u00e9s a dir, de totes les files de la taula). S'admeten les cl\u00e0usules GROUP BY , HAVING i ORDER BY , que funcionen igual que en SQL. S'admeten subconsultes , si \u00e9s que el SGBD les admet, clar. Ac\u00ed teniu uns quants exemples: from Comarca Torna totes les inst\u00e0ncies de Comarques from Comarca order by nomC Torna totes les inst\u00e0ncies de Comarques ordenades per nom de comarca from Comarca where provincia='Castell\u00f3' Torna totes les comarques de la prov\u00edncia de Castell\u00f3 from Comarca where provincia in ('Castell\u00f3','Alacant') Torna totes les comarques de les prov\u00edncies de Castell\u00f3 i Alacant from Poblacio where altura between 700 and 750 Torna totes les poblacions amb una altura entre 700 i 750 m from Institut where codpostal is null Torna els instituts que no tenen codi postal (no hi ha ningun) from Comarca where nomC like 'A%' Torna les comarques el nom de les quals comen\u00e7a per A select provincia, count(*) from Comarca group by provincia Torna les prov\u00edncies i el n\u00famero de comarques en cadascuna select poblacio.nom , count(*) from Institut group by poblacio.nom Torna el nom de la poblaci\u00f3 i el n\u00famero d'instituts que t\u00e9 (nom\u00e9s d'aquelles que tenen algun institut) select comarca.nomC , avg(altura) from Poblacio group by comarca.nomC having avg(altura) > 700 Torna el nom de la comarca i l'altura mitjana d'aquelles comarques que tenen una altura mitjana m\u00e9s gran que 700 from Poblacio where altura > (select avg(altura) from Poblacio) Torna les poblacions que tenen una altura major que la mitjana from Poblacio p1 where p1.altura > (select avg(altura) from Poblacio p2 where p2.comarca=p1.comarca) Torna les poblacions que tenen una altura major que la mitjana de la seua comarca HQL tamb\u00e9 admet reunions en les classes. Per a fer una reuni\u00f3 normal, podem posar la condici\u00f3 en el where i ja est\u00e0, per\u00f2 si volem fer una reuni\u00f3 externa (un left join per exemple) no ens valdr\u00e0 aquesta opci\u00f3, i haurem de fer la reuni\u00f3. La sintaxi de la reuni\u00f3 \u00e9s diferent en HQL. En SQL pos\u00e0vem la condici\u00f3 en l'apartat ON , despr\u00e9s d'haver posat les taules, i pos\u00e0vem una condici\u00f3 d'igualtat entre els camps d'una i altra taula SELECT ... FROM POBLACIO LEFT JOIN INSTITUT ON POBLACIO.cod_m=INSTITUT.cod_m En canvi en HQL despr\u00e9s de les taules no posem ON , sin\u00f3 que posarem l'enlla\u00e7 entre les dues taules. Aquest enlla\u00e7 coincideix amb el nom de la col\u00b7lecci\u00f3 d'elements de l'altre taula. En el cas de l'exemple que estem veient \u00e9s institutses . Per tant una reuni\u00f3 entre Poblacions i Instituts es definiria aix\u00ed from Poblacio p left join p.instituts Vejam un exemple un poc m\u00e9s elaborat, on traurem el nom de la poblaci\u00f3 amb el n\u00famero d'instituts que t\u00e9, fins i tot d'aquells que no tenen institut select p.nom, count(i.codi) from Poblacio p left join p.instituts i group by p.nom order by p.nom Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"11 - Resum del llenguatge HQL"},{"location":"11__resum_del_llenguatge_hql/#11-resum-del-llenguatge-hql","text":"Veurem d'una manera molt r\u00e0pida el llenguatge HQL. Sobretot insistirem en les difer\u00e8ncies amb SQL, al qual se sembla molt. La cl\u00e0usula SELECT \u00e9s opcional. Si no la posem equival a agafar totes les propietats (\u00e9s a dir, equivalent a SELECT * de SQL). \u00c9s una operaci\u00f3 molt habitual, ja que d'aquesta manera la llista d'objectes tornats \u00e9s de la classe marcada en el from. Es poden utilitzar \u00e0lies de les classes, posant AS despr\u00e9s de la classe i abans de l'\u00e0lies. Tamb\u00e9 podem prescindir del AS. Si utilitzem \u00e0lies, per a fer refer\u00e8ncia a la classe haurem d'utilitzar sempre l'\u00e0lies. Per exemple FROM Comarques AS c , o senzillament FROM Comarques c . La cl\u00e0usula WHERE \u00e9s opcional. Si no la posem equival a agafar de totes les inst\u00e0ncies de la classe associada (\u00e9s a dir, de totes les files de la taula). S'admeten les cl\u00e0usules GROUP BY , HAVING i ORDER BY , que funcionen igual que en SQL. S'admeten subconsultes , si \u00e9s que el SGBD les admet, clar. Ac\u00ed teniu uns quants exemples: from Comarca Torna totes les inst\u00e0ncies de Comarques from Comarca order by nomC Torna totes les inst\u00e0ncies de Comarques ordenades per nom de comarca from Comarca where provincia='Castell\u00f3' Torna totes les comarques de la prov\u00edncia de Castell\u00f3 from Comarca where provincia in ('Castell\u00f3','Alacant') Torna totes les comarques de les prov\u00edncies de Castell\u00f3 i Alacant from Poblacio where altura between 700 and 750 Torna totes les poblacions amb una altura entre 700 i 750 m from Institut where codpostal is null Torna els instituts que no tenen codi postal (no hi ha ningun) from Comarca where nomC like 'A%' Torna les comarques el nom de les quals comen\u00e7a per A select provincia, count(*) from Comarca group by provincia Torna les prov\u00edncies i el n\u00famero de comarques en cadascuna select poblacio.nom , count(*) from Institut group by poblacio.nom Torna el nom de la poblaci\u00f3 i el n\u00famero d'instituts que t\u00e9 (nom\u00e9s d'aquelles que tenen algun institut) select comarca.nomC , avg(altura) from Poblacio group by comarca.nomC having avg(altura) > 700 Torna el nom de la comarca i l'altura mitjana d'aquelles comarques que tenen una altura mitjana m\u00e9s gran que 700 from Poblacio where altura > (select avg(altura) from Poblacio) Torna les poblacions que tenen una altura major que la mitjana from Poblacio p1 where p1.altura > (select avg(altura) from Poblacio p2 where p2.comarca=p1.comarca) Torna les poblacions que tenen una altura major que la mitjana de la seua comarca HQL tamb\u00e9 admet reunions en les classes. Per a fer una reuni\u00f3 normal, podem posar la condici\u00f3 en el where i ja est\u00e0, per\u00f2 si volem fer una reuni\u00f3 externa (un left join per exemple) no ens valdr\u00e0 aquesta opci\u00f3, i haurem de fer la reuni\u00f3. La sintaxi de la reuni\u00f3 \u00e9s diferent en HQL. En SQL pos\u00e0vem la condici\u00f3 en l'apartat ON , despr\u00e9s d'haver posat les taules, i pos\u00e0vem una condici\u00f3 d'igualtat entre els camps d'una i altra taula SELECT ... FROM POBLACIO LEFT JOIN INSTITUT ON POBLACIO.cod_m=INSTITUT.cod_m En canvi en HQL despr\u00e9s de les taules no posem ON , sin\u00f3 que posarem l'enlla\u00e7 entre les dues taules. Aquest enlla\u00e7 coincideix amb el nom de la col\u00b7lecci\u00f3 d'elements de l'altre taula. En el cas de l'exemple que estem veient \u00e9s institutses . Per tant una reuni\u00f3 entre Poblacions i Instituts es definiria aix\u00ed from Poblacio p left join p.instituts Vejam un exemple un poc m\u00e9s elaborat, on traurem el nom de la poblaci\u00f3 amb el n\u00famero d'instituts que t\u00e9, fins i tot d'aquells que no tenen institut select p.nom, count(i.codi) from Poblacio p left join p.instituts i group by p.nom order by p.nom Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"11 - Resum del llenguatge HQL"},{"location":"12_generaci_de_taules_a_partir_de_les_classes_voluntari/","text":"12. Generaci\u00f3 de taules a partir de les classes (voluntari) VOLUNTARI Durant aquest tema, i tamb\u00e9 en els exercicis, hem treballat sobre projectes en els quals a partir de les taules d'una Base de Dades ja creada en qualsevol Sistema Gestor de Bases de Dades (excepte SQLite) hem generat les classes. Funciona molt b\u00e9 aquesta generaci\u00f3 de classes amb Hibernate. Tamb\u00e9 \u00e9s possible el proc\u00e9s invers, \u00e9s a dir, generar les taules en una Base de Dades a partir de les classes creades en un projecte. Veurem un exemple molt senzill de com \u00e9s possible. Tanmateix hem de dir ja que aquesta manera de funcionar no \u00e9s tan efectiva com la inversa, i si l'estructura de classes \u00e9s complexa, podem tenir problemes per a generar les taules. Per aix\u00f2 l'exemple que posarem \u00e9s molt senzil. Aquesta pregunta \u00e9s totalment volunt\u00e0ria. Si no teniu ganes o temps, no fa falta que feu l'exemple mostrat a continuaci\u00f3. El que s\u00ed que \u00e9s obligatori \u00e9s la generaci\u00f3 de classes a partir de les taules, vist anteriorment. L'exemple que intentarem implementar \u00e9s una part de l'exemple de la biblioteca, vist ja en el tema 4. Nom\u00e9s treballarem sobre 2 classes Editorial i Llibre . Aquestes s\u00f3n les classes, millor dit les propietats de les classes, com veieu amb una estructura molt senzilla: class Editorial (var codEd: String, var nom: String, var web: String, var llibres: MutableSet<Llibre>) class Llibre (var isbn: String, var titol: String, var pagines: Int, var editorial: Editorial) Com veieu tenim una propietat en la classe Llibre que \u00e9s de tipus Editorial , per a marcar l'editorial del llibre. I en Editorial tenim un MutableSet de tipus Llibre per a posar tots els llibres de l'editorial. La manera de crear les taules \u00e9s molt senzilla, encara que si comencem de zero \u00e9s un poc laboriosa, i fa falta comprendre els fitxers de mapatge hbm.xml en profunditat, ja que els construirem nosaltres. Despr\u00e9s ser\u00e0 tan senzill com guardar dades, fer-les permanents. Incloent una propietat en el fitxer hibernate.cfg.xml es crearan les taules abans de guardar les dades. Els fitxers de mapatge serien aquestos: Editorial.hbm.xml <hibernate-mapping> <class name=\"biblio.Editorial\" table=\"editorial\" schema=\"public\" catalog=\"biblio_gen\"> <id name=\"codEd\" column=\"cod_ed\"/> <property name=\"nom\" column=\"nom\"/> <property name=\"web\" column=\"web\"/> <set name=\"llibres\" inverse=\"true\"> <key> <column name=\"cod_ed\" not-null=\"true\"/> </key> <one-to-many not-found=\"ignore\" class=\"biblio.Llibre\"/> </set> </class> </hibernate-mapping> Llibre.hbm.xml <hibernate-mapping> <class name=\"biblio.Llibre\" table=\"llibre\" schema=\"public\" catalog=\"biblio_gen\"> <id name=\"isbn\" column=\"isbn\"/> <property name=\"titol\" column=\"titol\"/> <property name=\"pagines\" column=\"pagines\"/> <many-to-one name=\"editorial\" class=\"biblio.Editorial\"> <column name=\"cod_ed\" not-null=\"true\"/> </many-to-one> </class> </hibernate-mapping> Evidentment haurem de fer la connexi\u00f3 amb la Base de Dades i incorporar llibreries d'Hibernate, igual com hem fet fins el moment. Per a aquest exemple, utilitzarem un altra Base de Dades, usuari i contrasenya, tamb\u00e9 en PostgreSQL. Ser\u00e0 sobre la BD, usuari i contrasenya biblio_gen . Una vegada feta la connexi\u00f3 a la Base de Dades, utilitzarem aquest hibernate.cfg.xml : <?xml version='1.0' encoding='utf-8'?> <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"connection.url\">jdbc:postgresql://89.36.214.106:5432/biblio_gen</property> <property name=\"connection.driver_class\">org.postgresql.Driver</property> <property name=\"connection.username\">biblio_gen</property> <property name=\"connection.password\">biblio_gen</property> <!-- DB schema will be updated if needed --> <property name=\"hibernate.hbm2ddl.auto\">create</property> <mapping resource=\"Editorial.hbm.xml\"/> <mapping resource=\"Llibre.hbm.xml\"/> </session-factory> </hibernate-configuration> Aquest fitxer el podr\u00edem haver generat mapejant de la connexi\u00f3, per\u00f2 sense mapejar les taules, clar, que encara no existeixen. I sobre ell far\u00edem algun canvi: En la l\u00ednia 12 llavar\u00edem el comentari sobre aquesta propietat. El que li estem dient \u00e9s que ha de crear les taules (t\u00e9 l'inconvenient que si ja existien, esborrar\u00e0 les anteriors) Les l\u00ednies 13 i 14 les hem incloses per a mapejar Editorial i Llibre amb aquestos fitxers de mapatge I nom\u00e9s faltar\u00e0 un programeta que intente guardar les dades. Aquest seria un exemple: package biblio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val e = Editorial(\"ed5\",\"Tabarca Llibres\",\"www.tabarcallibres.com\", mutableSetOf<Llibre>()) val ll = Llibre(\"8480241815\",\"L'ull de la boira\",141,e) e.llibres.add(ll) sessio.persist(e) sessio.persist(ll) t.commit() sessio.close() } En el seg\u00fcent v\u00eddeo s'arreplega tot el proc\u00e9s, des de la creaci\u00f3 del projecte fins tenir les taules creades. Nota En Eclipse es pot automatitzar un poc m\u00e9s el proc\u00e9s, ja que \u00e9s capa\u00e7 de generar quasi totes les anotaions necess\u00e0ries per a poder mapejar les classes (sense utilitzar els fitxers de mapatge hbm.xml ). Les classes, en Java, quedarien aix\u00ed: classe Editorial classe Llibre import javax.persistence.Entity; import javax.persistence.Id; @Entity public class Editorial { ** @Id** String codi; String nom; String web; **** public Editorial() { super(); } public Editorial(String codi, String nom, String web) { super(); this.codi = codi; this.nom = nom; this.web = web; } public String getCodi() { return codi; } public void setCodi(String codi) { this.codi = codi; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } public String getWeb() { return web; } public void setWeb(String web) { this.web = web; } } **import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; @Entity public class Llibre { @Id String isbn; String titol; int pagines; @ManyToOne Editorial editorial; public Llibre() { super(); } public Llibre(String isbn, String titol, int pagines, Editorial editorial) { super(); this.isbn = isbn; this.titol = titol; this.pagines = pagines; this.editorial = editorial; } public String getIsbn() { return isbn; } public void setIsbn(String isbn) { this.isbn = isbn; } public String getTitol() { return titol; } public void setTitol(String titol) { this.titol = titol; } public int getPagines() { return pagines; } public void setPagines(int pagines) { this.pagines = pagines; } public Editorial getEditorial() { return editorial; } public void setEditorial(Editorial editorial) { this.editorial = editorial; } }** I amb aquesta informaci\u00f3 es podran generar les sent\u00e8ncies SQL que crearan les taules en la Base de Dades. Aquestes sent\u00e8ncies serien: taula EDITORIAL | taula LLIBRE ---|--- * *create table Editorial ( codi varchar(255) not null, nom varchar(255), web varchar(255), primary key (codi) ); | * *create table Llibre ( isbn varchar(255) not null, pagines int4 not null, titol varchar(255), editorial_codi varchar(255), primary key (isbn) ); alter table Llibre add constraint FKap3159swqtnuj1i2q43xm0wk2 foreign key (editorial_codi) references Editorial;** Observeu com fins i tot es crearia la clau externa en LLIBRE que apunta a EDITORIAL Aquest v\u00eddeo arreplega tot el proc\u00e9s: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"12. Generaci\u00f3 de taules a partir de les classes (voluntari)"},{"location":"12_generaci_de_taules_a_partir_de_les_classes_voluntari/#12-generacio-de-taules-a-partir-de-les-classes-voluntari","text":"VOLUNTARI Durant aquest tema, i tamb\u00e9 en els exercicis, hem treballat sobre projectes en els quals a partir de les taules d'una Base de Dades ja creada en qualsevol Sistema Gestor de Bases de Dades (excepte SQLite) hem generat les classes. Funciona molt b\u00e9 aquesta generaci\u00f3 de classes amb Hibernate. Tamb\u00e9 \u00e9s possible el proc\u00e9s invers, \u00e9s a dir, generar les taules en una Base de Dades a partir de les classes creades en un projecte. Veurem un exemple molt senzill de com \u00e9s possible. Tanmateix hem de dir ja que aquesta manera de funcionar no \u00e9s tan efectiva com la inversa, i si l'estructura de classes \u00e9s complexa, podem tenir problemes per a generar les taules. Per aix\u00f2 l'exemple que posarem \u00e9s molt senzil. Aquesta pregunta \u00e9s totalment volunt\u00e0ria. Si no teniu ganes o temps, no fa falta que feu l'exemple mostrat a continuaci\u00f3. El que s\u00ed que \u00e9s obligatori \u00e9s la generaci\u00f3 de classes a partir de les taules, vist anteriorment. L'exemple que intentarem implementar \u00e9s una part de l'exemple de la biblioteca, vist ja en el tema 4. Nom\u00e9s treballarem sobre 2 classes Editorial i Llibre . Aquestes s\u00f3n les classes, millor dit les propietats de les classes, com veieu amb una estructura molt senzilla: class Editorial (var codEd: String, var nom: String, var web: String, var llibres: MutableSet<Llibre>) class Llibre (var isbn: String, var titol: String, var pagines: Int, var editorial: Editorial) Com veieu tenim una propietat en la classe Llibre que \u00e9s de tipus Editorial , per a marcar l'editorial del llibre. I en Editorial tenim un MutableSet de tipus Llibre per a posar tots els llibres de l'editorial. La manera de crear les taules \u00e9s molt senzilla, encara que si comencem de zero \u00e9s un poc laboriosa, i fa falta comprendre els fitxers de mapatge hbm.xml en profunditat, ja que els construirem nosaltres. Despr\u00e9s ser\u00e0 tan senzill com guardar dades, fer-les permanents. Incloent una propietat en el fitxer hibernate.cfg.xml es crearan les taules abans de guardar les dades. Els fitxers de mapatge serien aquestos: Editorial.hbm.xml <hibernate-mapping> <class name=\"biblio.Editorial\" table=\"editorial\" schema=\"public\" catalog=\"biblio_gen\"> <id name=\"codEd\" column=\"cod_ed\"/> <property name=\"nom\" column=\"nom\"/> <property name=\"web\" column=\"web\"/> <set name=\"llibres\" inverse=\"true\"> <key> <column name=\"cod_ed\" not-null=\"true\"/> </key> <one-to-many not-found=\"ignore\" class=\"biblio.Llibre\"/> </set> </class> </hibernate-mapping> Llibre.hbm.xml <hibernate-mapping> <class name=\"biblio.Llibre\" table=\"llibre\" schema=\"public\" catalog=\"biblio_gen\"> <id name=\"isbn\" column=\"isbn\"/> <property name=\"titol\" column=\"titol\"/> <property name=\"pagines\" column=\"pagines\"/> <many-to-one name=\"editorial\" class=\"biblio.Editorial\"> <column name=\"cod_ed\" not-null=\"true\"/> </many-to-one> </class> </hibernate-mapping> Evidentment haurem de fer la connexi\u00f3 amb la Base de Dades i incorporar llibreries d'Hibernate, igual com hem fet fins el moment. Per a aquest exemple, utilitzarem un altra Base de Dades, usuari i contrasenya, tamb\u00e9 en PostgreSQL. Ser\u00e0 sobre la BD, usuari i contrasenya biblio_gen . Una vegada feta la connexi\u00f3 a la Base de Dades, utilitzarem aquest hibernate.cfg.xml : <?xml version='1.0' encoding='utf-8'?> <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"connection.url\">jdbc:postgresql://89.36.214.106:5432/biblio_gen</property> <property name=\"connection.driver_class\">org.postgresql.Driver</property> <property name=\"connection.username\">biblio_gen</property> <property name=\"connection.password\">biblio_gen</property> <!-- DB schema will be updated if needed --> <property name=\"hibernate.hbm2ddl.auto\">create</property> <mapping resource=\"Editorial.hbm.xml\"/> <mapping resource=\"Llibre.hbm.xml\"/> </session-factory> </hibernate-configuration> Aquest fitxer el podr\u00edem haver generat mapejant de la connexi\u00f3, per\u00f2 sense mapejar les taules, clar, que encara no existeixen. I sobre ell far\u00edem algun canvi: En la l\u00ednia 12 llavar\u00edem el comentari sobre aquesta propietat. El que li estem dient \u00e9s que ha de crear les taules (t\u00e9 l'inconvenient que si ja existien, esborrar\u00e0 les anteriors) Les l\u00ednies 13 i 14 les hem incloses per a mapejar Editorial i Llibre amb aquestos fitxers de mapatge I nom\u00e9s faltar\u00e0 un programeta que intente guardar les dades. Aquest seria un exemple: package biblio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val e = Editorial(\"ed5\",\"Tabarca Llibres\",\"www.tabarcallibres.com\", mutableSetOf<Llibre>()) val ll = Llibre(\"8480241815\",\"L'ull de la boira\",141,e) e.llibres.add(ll) sessio.persist(e) sessio.persist(ll) t.commit() sessio.close() } En el seg\u00fcent v\u00eddeo s'arreplega tot el proc\u00e9s, des de la creaci\u00f3 del projecte fins tenir les taules creades. Nota En Eclipse es pot automatitzar un poc m\u00e9s el proc\u00e9s, ja que \u00e9s capa\u00e7 de generar quasi totes les anotaions necess\u00e0ries per a poder mapejar les classes (sense utilitzar els fitxers de mapatge hbm.xml ). Les classes, en Java, quedarien aix\u00ed: classe Editorial classe Llibre import javax.persistence.Entity; import javax.persistence.Id; @Entity public class Editorial { ** @Id** String codi; String nom; String web; **** public Editorial() { super(); } public Editorial(String codi, String nom, String web) { super(); this.codi = codi; this.nom = nom; this.web = web; } public String getCodi() { return codi; } public void setCodi(String codi) { this.codi = codi; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } public String getWeb() { return web; } public void setWeb(String web) { this.web = web; } } **import javax.persistence.Entity; import javax.persistence.Id; import javax.persistence.ManyToOne; @Entity public class Llibre { @Id String isbn; String titol; int pagines; @ManyToOne Editorial editorial; public Llibre() { super(); } public Llibre(String isbn, String titol, int pagines, Editorial editorial) { super(); this.isbn = isbn; this.titol = titol; this.pagines = pagines; this.editorial = editorial; } public String getIsbn() { return isbn; } public void setIsbn(String isbn) { this.isbn = isbn; } public String getTitol() { return titol; } public void setTitol(String titol) { this.titol = titol; } public int getPagines() { return pagines; } public void setPagines(int pagines) { this.pagines = pagines; } public Editorial getEditorial() { return editorial; } public void setEditorial(Editorial editorial) { this.editorial = editorial; } }** I amb aquesta informaci\u00f3 es podran generar les sent\u00e8ncies SQL que crearan les taules en la Base de Dades. Aquestes sent\u00e8ncies serien: taula EDITORIAL | taula LLIBRE ---|--- * *create table Editorial ( codi varchar(255) not null, nom varchar(255), web varchar(255), primary key (codi) ); | * *create table Llibre ( isbn varchar(255) not null, pagines int4 not null, titol varchar(255), editorial_codi varchar(255), primary key (isbn) ); alter table Llibre add constraint FKap3159swqtnuj1i2q43xm0wk2 foreign key (editorial_codi) references Editorial;** Observeu com fins i tot es crearia la clau externa en LLIBRE que apunta a EDITORIAL Aquest v\u00eddeo arreplega tot el proc\u00e9s: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"12. Generaci\u00f3 de taules a partir de les classes (voluntari)"},{"location":"1__introducci/","text":"1 - Introducci\u00f3 Ja hem vist que a trav\u00e9s de JDBC podem connectar f\u00e0cilment a Bases de Dades Relacionals. Per\u00f2 tenim el problema del desfasament Objecte-Relacional. Com que en Java i Kotlin utilitzem objectes, ha d'haver una part important de programaci\u00f3 en la conversi\u00f3 d'aquestos objectes a taules, per a que es puguen guardar de forma permanent. Aix\u00f2 ho hem intentat comprovar en l' exercici 4.4 , destinat a fer la classe GestionarRutesBD de manera que siga transparent la persist\u00e8ncia de les dades a qui utilitza aquesta classe. Sobre un exemple molt senzill, hem vist que la traducci\u00f3 entre els objectes i \u00fanicament dues taules, ja suposava una miqueta de esfor\u00e7. Podem veure per tant que en una aplicaci\u00f3 una miqueta m\u00e9s complicada, fer la traducci\u00f3 entre objectes i taules \u00e9s una feina que es pot fer, per\u00f2 que costar\u00e0 prou. Les eines de mapatge objecte-relacional ( ORM : Object-Relational Mapping) intenten minimitzar tant com siga possible el desfasament objecte- relacional, automatitzant el proc\u00e9s de trasp\u00e0s d\u2019un sistema a l\u2019altre. En certa manera podr\u00edem dir que implementen una Base de Dades Orientada a Objectes virtual perqu\u00e8 aporten caracter\u00edstiques pr\u00f2pies del paradigma OO, per\u00f2 el substrat on s\u2019acaben guardant els objectes \u00e9s un SGBD Relacional. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Introducci\u00f3"},{"location":"1__introducci/#1-introduccio","text":"Ja hem vist que a trav\u00e9s de JDBC podem connectar f\u00e0cilment a Bases de Dades Relacionals. Per\u00f2 tenim el problema del desfasament Objecte-Relacional. Com que en Java i Kotlin utilitzem objectes, ha d'haver una part important de programaci\u00f3 en la conversi\u00f3 d'aquestos objectes a taules, per a que es puguen guardar de forma permanent. Aix\u00f2 ho hem intentat comprovar en l' exercici 4.4 , destinat a fer la classe GestionarRutesBD de manera que siga transparent la persist\u00e8ncia de les dades a qui utilitza aquesta classe. Sobre un exemple molt senzill, hem vist que la traducci\u00f3 entre els objectes i \u00fanicament dues taules, ja suposava una miqueta de esfor\u00e7. Podem veure per tant que en una aplicaci\u00f3 una miqueta m\u00e9s complicada, fer la traducci\u00f3 entre objectes i taules \u00e9s una feina que es pot fer, per\u00f2 que costar\u00e0 prou. Les eines de mapatge objecte-relacional ( ORM : Object-Relational Mapping) intenten minimitzar tant com siga possible el desfasament objecte- relacional, automatitzant el proc\u00e9s de trasp\u00e0s d\u2019un sistema a l\u2019altre. En certa manera podr\u00edem dir que implementen una Base de Dades Orientada a Objectes virtual perqu\u00e8 aporten caracter\u00edstiques pr\u00f2pies del paradigma OO, per\u00f2 el substrat on s\u2019acaben guardant els objectes \u00e9s un SGBD Relacional. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1 - Introducci\u00f3"},{"location":"2__concepte_de_mapatge_objecterelacional/","text":"2 - Concepte de mapatge objecte-relacional Les eines de mapatge objecte-relacional automatitzen els processos necessaris d\u2019intercanvi de dades entre Sistemes Orientats a Objectes (OO) i Sistemes Relacionals. Per tant ens ajuden a salvar el desfasament Objecte-Relacional de forma molt c\u00f2moda. L\u2019automatitzaci\u00f3 s\u2019aconsegueix gr\u00e0cies a un conjunt de metadades que descriuen quin proc\u00e9s cal utilitzar i quina correspond\u00e8ncia hi ha entre les dades primitives d\u2019ambd\u00f3s sistemes i les estructures que les suporten. La descripci\u00f3 m\u00e9s senzilla que han de fer les metadades \u00e9s la d\u2019establir una correspond\u00e8ncia directa entre classes i taules, i a nivell m\u00e9s b\u00e0sic entre els atributs de tipus primitius i els camps o columnes. Tamb\u00e9 caldr\u00e0 identificar l\u2019atribut corresponent al camp que actuar\u00e0 com a clau prim\u00e0ria. Lamentablement, no sempre es podr\u00e0 establir aquest tipus de correspond\u00e8ncies directes i caldr\u00e0 que les metadades puguen expressar molta m\u00e9s complexitat. Aquestos s\u00f3n alguns dels problemes que ens podem trobar: A vegades pot interessar guardar una propietat en m\u00e9s d\u2019una columna o unes quantes propietats en una columna \u00fanica. Pot haver propietats que no es guarden i camps guardats que no es vegen reflectits als objectes. Quan els atributs no siguen tipus de dades primitius caldr\u00e0 saber tamb\u00e9 si haurem de guardar les dades en una taula diferent o en la mateixa taula i, en cas de que siga en taules diferents, quins atributs haurem de fer servir com a claus externes, qui tindr\u00e0 la responsabilitat de realitzar l\u2019emmagatzematge, etc. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Concepte de mapatge objecte-relacional"},{"location":"2__concepte_de_mapatge_objecterelacional/#2-concepte-de-mapatge-objecte-relacional","text":"Les eines de mapatge objecte-relacional automatitzen els processos necessaris d\u2019intercanvi de dades entre Sistemes Orientats a Objectes (OO) i Sistemes Relacionals. Per tant ens ajuden a salvar el desfasament Objecte-Relacional de forma molt c\u00f2moda. L\u2019automatitzaci\u00f3 s\u2019aconsegueix gr\u00e0cies a un conjunt de metadades que descriuen quin proc\u00e9s cal utilitzar i quina correspond\u00e8ncia hi ha entre les dades primitives d\u2019ambd\u00f3s sistemes i les estructures que les suporten. La descripci\u00f3 m\u00e9s senzilla que han de fer les metadades \u00e9s la d\u2019establir una correspond\u00e8ncia directa entre classes i taules, i a nivell m\u00e9s b\u00e0sic entre els atributs de tipus primitius i els camps o columnes. Tamb\u00e9 caldr\u00e0 identificar l\u2019atribut corresponent al camp que actuar\u00e0 com a clau prim\u00e0ria. Lamentablement, no sempre es podr\u00e0 establir aquest tipus de correspond\u00e8ncies directes i caldr\u00e0 que les metadades puguen expressar molta m\u00e9s complexitat. Aquestos s\u00f3n alguns dels problemes que ens podem trobar: A vegades pot interessar guardar una propietat en m\u00e9s d\u2019una columna o unes quantes propietats en una columna \u00fanica. Pot haver propietats que no es guarden i camps guardats que no es vegen reflectits als objectes. Quan els atributs no siguen tipus de dades primitius caldr\u00e0 saber tamb\u00e9 si haurem de guardar les dades en una taula diferent o en la mateixa taula i, en cas de que siga en taules diferents, quins atributs haurem de fer servir com a claus externes, qui tindr\u00e0 la responsabilitat de realitzar l\u2019emmagatzematge, etc. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2 - Concepte de mapatge objecte-relacional"},{"location":"3__eines_de_mapatge/","text":"3 - Eines de mapatge Actualment hi ha moltes eines de mapatge en el mercat. Existeixen eines de mapatge per a la major part de llenguatges orientats a objectes PHP, Objective-C, C++, SmallTalk i evidentment Java/Kotlin. B\u00e0sicament s\u00f3n eines en les quals podem distingir tres aspectes conceptuals clarament diferenciats: Un sistema per expressar el mapatge entre les classes i l\u2019esquema de la Base de Dades, Un llenguatge de consulta orientat a objectes (que en realitat accedir\u00e0 a les taules) i per tant ens permetr\u00e0 salvar el desfasament O-R Un nucli funcional que possibilita la sincronitzaci\u00f3 dels objectes persistents de l\u2019aplicaci\u00f3 amb la Base de Dades. T\u00e8cniques de mapatge Entre les t\u00e8cniques que aquestes eines fan servir per plasmar els mapes O-R, destaquem: Les que incrusten les definicions dins el codi de les classes Les que guarden les definicions en fitxers independents. Les primeres solen ser t\u00e8cniques molt vinculades al llenguatge de programaci\u00f3, aix\u00ed per exemple, en C++ se solen fer servir macros i en Java/Kotlin s\u2019utilitzen anotacions . Les t\u00e8cniques de definici\u00f3 basades en fitxers independents del codi solen utilitzar el format XML , perqu\u00e8 \u00e9s un llenguatge molt expressiu i f\u00e0cilment extensible. La major part d\u2019eines accepten les dues t\u00e8cniques de mapatge anteriors, i fins i tot permeten la conviv\u00e8ncia dins d'una mateixa aplicaci\u00f3. Les t\u00e8cniques que utilitzen el propi llenguatge de programaci\u00f3 per incrustar el mapatge dins el codi presenten una corba d\u2019aprenentatge m\u00e9s baixa per a desenvolupadors experimentats en el llenguatge amfitri\u00f3, per\u00f2 per contra no ser\u00e0 possible aprofitar les definicions si es decideix canviar de llenguatge de programaci\u00f3. En canvi, fent servir les t\u00e8cniques basades en XML s\u00ed que es poden reutilitzar les definicions per a diferents llenguatges, sempre que l\u2019eina utilitzada estiga disponible en el llenguatge de programaci\u00f3 requerit o b\u00e9 si el format de les definicions segueix alguna especificaci\u00f3 est\u00e0ndard. A hores d'ara \u00e9s dif\u00edcil dir per on s'encaminaran els est\u00e0ndards. Aix\u00f2 s\u00ed, la major part d\u2019eines utilitzen una sintaxi prou similar per a expressar les definicions del mapatge, encara que \u00f2bviament sempre hi ha difer\u00e8ncies que no els fan del tot compatibles. Llenguatges de consulta El llenguatge de consulta m\u00e9s utilitzat per la major part d\u2019eines \u00e9s el llenguatge anomenat OQL ( Object Query Language ) o una variant del mateix. Es tracta d\u2019un llenguatge especificat per l\u2019ODMG. Presenta molta similitud amb SQL, ja que que els dos s\u00f3n llenguatges d\u2019interrogaci\u00f3 no procedimental, per\u00f2 l\u2019OQL est\u00e0 totalment orientat a objectes. \u00c9s a dir, en la consulta fem servir la sintaxi pr\u00f2pia dels objectes i els resultats obtinguts retornen objectes o col\u00b7leccions d\u2019objectes. Es tracta del llenguatge d\u2019interrogaci\u00f3 que tamb\u00e9 utilitzen moltes bases de dades orientades a objecte, la qual cosa el fa un dels est\u00e0ndards m\u00e9s populars i coneguts. Hi ha altres llenguatges de consulta orientats a objectes, per\u00f2 no tan estesos com OQL. T\u00e8cniques de sincronitzaci\u00f3 La sincronitzaci\u00f3 amb la base de dades \u00e9s segurament un dels aspectes m\u00e9s cr\u00edtics de les eines de mapatge. Solen ser processos molt complexos, on trobem implicades sofisticades t\u00e8cniques de programaci\u00f3 per a poder descobrir els canvis que van patint els objectes (i aix\u00ed poder guardar-los), a crear i inicialitzar les noves inst\u00e0ncies que calga posar en joc dins l\u2019aplicaci\u00f3 d\u2019acord amb les dades guardades o tamb\u00e9 a extreure la informaci\u00f3 dels objectes per revertir-la a les taules del SGBD. Aquest \u00e9s probablement l\u2019aspecte que m\u00e9s diferencia les eines entre elles. Les principals t\u00e8cniques utilitzades s\u00f3n la precompilaci\u00f3, la postcompilaci\u00f3 i la reflexi\u00f3. El llenguatge de programaci\u00f3 suportat per l\u2019eina influir\u00e0 molt\u00edssim en les solucions adoptades per resoldre la sincronitzaci\u00f3. Per exemple, C++ admet precompilaci\u00f3, per\u00f2 no reflexi\u00f3, mentre que Java/Kotlin admet postcompilaci\u00f3 i reflexi\u00f3. JDO ( Java Data Objects ) \u00e9s un est\u00e0ndard de persist\u00e8ncia per a Java (i per tant per a Kotlin) desenvolupat per Apache. El projecte inclou, a m\u00e9s de l\u2019especificaci\u00f3 de l\u2019est\u00e0ndard, el desenvolupament d\u2019un marc de persist\u00e8ncia basat en la postcompilaci\u00f3. Aquesta t\u00e8cnica consisteix en realitzar dues compilacions a les classes que requereixen persist\u00e8ncia. La primera, realitzada pel jdk, generar\u00e0 els bytecode est\u00e0ndards (\u00e9s a dir els \"executables\" de Java/Kotlin, els que es poden executar en la m\u00e0quina virtual Java). La segona compilaci\u00f3, fent servir les indicacions descrites en els documents de mapatge, modificar\u00e0 els bytecode generats i hi afegir\u00e0 nova funcionalitat necess\u00e0ria per dur a terme la persist\u00e8ncia d\u2019una forma transparent. JPA ( Java Persistence API ) \u00e9s tamb\u00e9 un est\u00e0ndard de persist\u00e8ncia. Es troba incorporat en el JDK des de la versi\u00f3 5. Hi ha diverses biblioteques que el suporten, totes elles basades en el principi de la reflexi\u00f3. Java \u00e9s un llenguatge que en compilar les classes incorpora metadades amb informaci\u00f3 pr\u00f2pia de la classe, com ara l\u2019estructura de dades interna, els m\u00e8todes que tinga disponibles, els par\u00e0metres necessaris per invocar els m\u00e8todes, etc. La m\u00e0quina virtual permet fer servir aquestes metadades per accedir a la informaci\u00f3 real guardada en els objectes, per invocar algun dels seus m\u00e8todes, per construir noves inst\u00e0ncies, etc. La postcompilaci\u00f3, usada per JDO, presenta l\u2019avantatge de ser m\u00e9s eficient, ja que incrusta codi compilat directament all\u00e0 on cal, mentre que la t\u00e8cnica de la reflexi\u00f3 ha d\u2019anar llegint les metadades i interpretant la manera d\u2019executar adequadament les ordres desitjades. Malauradament, JDO no ha acabat de quallar i poques iniciatives comercials l\u2019han seguit. Per contra JPA, \u00e9s la t\u00e8cnica que han utilitzat els dos gegants fortament implantats (Hibernate i EJB). Tot sembla apuntar que ser\u00e0 l\u2019escollit per cobrir l\u2019estandarditzaci\u00f3 de la persist\u00e8ncia en Java/Kotlin. En aquestos apunts utilitzarem Hibernate , que es basa en JPA. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3 - Eines de mapatge"},{"location":"3__eines_de_mapatge/#3-eines-de-mapatge","text":"Actualment hi ha moltes eines de mapatge en el mercat. Existeixen eines de mapatge per a la major part de llenguatges orientats a objectes PHP, Objective-C, C++, SmallTalk i evidentment Java/Kotlin. B\u00e0sicament s\u00f3n eines en les quals podem distingir tres aspectes conceptuals clarament diferenciats: Un sistema per expressar el mapatge entre les classes i l\u2019esquema de la Base de Dades, Un llenguatge de consulta orientat a objectes (que en realitat accedir\u00e0 a les taules) i per tant ens permetr\u00e0 salvar el desfasament O-R Un nucli funcional que possibilita la sincronitzaci\u00f3 dels objectes persistents de l\u2019aplicaci\u00f3 amb la Base de Dades. T\u00e8cniques de mapatge Entre les t\u00e8cniques que aquestes eines fan servir per plasmar els mapes O-R, destaquem: Les que incrusten les definicions dins el codi de les classes Les que guarden les definicions en fitxers independents. Les primeres solen ser t\u00e8cniques molt vinculades al llenguatge de programaci\u00f3, aix\u00ed per exemple, en C++ se solen fer servir macros i en Java/Kotlin s\u2019utilitzen anotacions . Les t\u00e8cniques de definici\u00f3 basades en fitxers independents del codi solen utilitzar el format XML , perqu\u00e8 \u00e9s un llenguatge molt expressiu i f\u00e0cilment extensible. La major part d\u2019eines accepten les dues t\u00e8cniques de mapatge anteriors, i fins i tot permeten la conviv\u00e8ncia dins d'una mateixa aplicaci\u00f3. Les t\u00e8cniques que utilitzen el propi llenguatge de programaci\u00f3 per incrustar el mapatge dins el codi presenten una corba d\u2019aprenentatge m\u00e9s baixa per a desenvolupadors experimentats en el llenguatge amfitri\u00f3, per\u00f2 per contra no ser\u00e0 possible aprofitar les definicions si es decideix canviar de llenguatge de programaci\u00f3. En canvi, fent servir les t\u00e8cniques basades en XML s\u00ed que es poden reutilitzar les definicions per a diferents llenguatges, sempre que l\u2019eina utilitzada estiga disponible en el llenguatge de programaci\u00f3 requerit o b\u00e9 si el format de les definicions segueix alguna especificaci\u00f3 est\u00e0ndard. A hores d'ara \u00e9s dif\u00edcil dir per on s'encaminaran els est\u00e0ndards. Aix\u00f2 s\u00ed, la major part d\u2019eines utilitzen una sintaxi prou similar per a expressar les definicions del mapatge, encara que \u00f2bviament sempre hi ha difer\u00e8ncies que no els fan del tot compatibles. Llenguatges de consulta El llenguatge de consulta m\u00e9s utilitzat per la major part d\u2019eines \u00e9s el llenguatge anomenat OQL ( Object Query Language ) o una variant del mateix. Es tracta d\u2019un llenguatge especificat per l\u2019ODMG. Presenta molta similitud amb SQL, ja que que els dos s\u00f3n llenguatges d\u2019interrogaci\u00f3 no procedimental, per\u00f2 l\u2019OQL est\u00e0 totalment orientat a objectes. \u00c9s a dir, en la consulta fem servir la sintaxi pr\u00f2pia dels objectes i els resultats obtinguts retornen objectes o col\u00b7leccions d\u2019objectes. Es tracta del llenguatge d\u2019interrogaci\u00f3 que tamb\u00e9 utilitzen moltes bases de dades orientades a objecte, la qual cosa el fa un dels est\u00e0ndards m\u00e9s populars i coneguts. Hi ha altres llenguatges de consulta orientats a objectes, per\u00f2 no tan estesos com OQL. T\u00e8cniques de sincronitzaci\u00f3 La sincronitzaci\u00f3 amb la base de dades \u00e9s segurament un dels aspectes m\u00e9s cr\u00edtics de les eines de mapatge. Solen ser processos molt complexos, on trobem implicades sofisticades t\u00e8cniques de programaci\u00f3 per a poder descobrir els canvis que van patint els objectes (i aix\u00ed poder guardar-los), a crear i inicialitzar les noves inst\u00e0ncies que calga posar en joc dins l\u2019aplicaci\u00f3 d\u2019acord amb les dades guardades o tamb\u00e9 a extreure la informaci\u00f3 dels objectes per revertir-la a les taules del SGBD. Aquest \u00e9s probablement l\u2019aspecte que m\u00e9s diferencia les eines entre elles. Les principals t\u00e8cniques utilitzades s\u00f3n la precompilaci\u00f3, la postcompilaci\u00f3 i la reflexi\u00f3. El llenguatge de programaci\u00f3 suportat per l\u2019eina influir\u00e0 molt\u00edssim en les solucions adoptades per resoldre la sincronitzaci\u00f3. Per exemple, C++ admet precompilaci\u00f3, per\u00f2 no reflexi\u00f3, mentre que Java/Kotlin admet postcompilaci\u00f3 i reflexi\u00f3. JDO ( Java Data Objects ) \u00e9s un est\u00e0ndard de persist\u00e8ncia per a Java (i per tant per a Kotlin) desenvolupat per Apache. El projecte inclou, a m\u00e9s de l\u2019especificaci\u00f3 de l\u2019est\u00e0ndard, el desenvolupament d\u2019un marc de persist\u00e8ncia basat en la postcompilaci\u00f3. Aquesta t\u00e8cnica consisteix en realitzar dues compilacions a les classes que requereixen persist\u00e8ncia. La primera, realitzada pel jdk, generar\u00e0 els bytecode est\u00e0ndards (\u00e9s a dir els \"executables\" de Java/Kotlin, els que es poden executar en la m\u00e0quina virtual Java). La segona compilaci\u00f3, fent servir les indicacions descrites en els documents de mapatge, modificar\u00e0 els bytecode generats i hi afegir\u00e0 nova funcionalitat necess\u00e0ria per dur a terme la persist\u00e8ncia d\u2019una forma transparent. JPA ( Java Persistence API ) \u00e9s tamb\u00e9 un est\u00e0ndard de persist\u00e8ncia. Es troba incorporat en el JDK des de la versi\u00f3 5. Hi ha diverses biblioteques que el suporten, totes elles basades en el principi de la reflexi\u00f3. Java \u00e9s un llenguatge que en compilar les classes incorpora metadades amb informaci\u00f3 pr\u00f2pia de la classe, com ara l\u2019estructura de dades interna, els m\u00e8todes que tinga disponibles, els par\u00e0metres necessaris per invocar els m\u00e8todes, etc. La m\u00e0quina virtual permet fer servir aquestes metadades per accedir a la informaci\u00f3 real guardada en els objectes, per invocar algun dels seus m\u00e8todes, per construir noves inst\u00e0ncies, etc. La postcompilaci\u00f3, usada per JDO, presenta l\u2019avantatge de ser m\u00e9s eficient, ja que incrusta codi compilat directament all\u00e0 on cal, mentre que la t\u00e8cnica de la reflexi\u00f3 ha d\u2019anar llegint les metadades i interpretant la manera d\u2019executar adequadament les ordres desitjades. Malauradament, JDO no ha acabat de quallar i poques iniciatives comercials l\u2019han seguit. Per contra JPA, \u00e9s la t\u00e8cnica que han utilitzat els dos gegants fortament implantats (Hibernate i EJB). Tot sembla apuntar que ser\u00e0 l\u2019escollit per cobrir l\u2019estandarditzaci\u00f3 de la persist\u00e8ncia en Java/Kotlin. En aquestos apunts utilitzarem Hibernate , que es basa en JPA. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3 - Eines de mapatge"},{"location":"4__arquitectura_hibernate/","text":"4 - Arquitectura Hibernate El producte que utilitzarem ser\u00e0 Hibernate . Aquesta eina ens permetr\u00e0 fer el mapatge entre objectes i les taules d'una Base de Dades. Aquestos objectes seran senzills, d'aquells que nom\u00e9s tenen les propietats, i m\u00e8todes get i set per a accedir a elles. Per a intercanviar la informaci\u00f3 entre aquestos objectes i la Base de Dades, utilitzarem la classe Session (que seria l'equivalent de Connection de JDBC). Aquesta classe ens proporciona els m\u00e8todes: save( objecte ) , que guardar\u00e0 l'objecte en la Base de Dades createQuery( consulta ) , que crear\u00e0 una consulta beginTransaction() , que comen\u00e7ar\u00e0 una transacci\u00f3 close() ... Amb a\u00e7\u00f2, interactuar amb la Base de Dades ser\u00e0 molt senzill, i no far\u00e0 falta executar sent\u00e8ncies SQL, tal i com ens passava en JDBC. Session no consumeix molta mem\u00f2ria i la seua creaci\u00f3 i destrucci\u00f3 \u00e9s molt barata, cosa que ens pot animar a crear (i destruir) una sessi\u00f3 per a cada acc\u00e9s a la Base de Dades. Ho anirem veient. El context que ens fa falta per a una aplicaci\u00f3 ser\u00e0: Configuration . S'utilitza per a configurar Hibernate. L'aplicaci\u00f3 utilitza una inst\u00e0ncia de Configuration per a especificar la ubicaci\u00f3 dels documents que descriuen el mapatge i tamb\u00e9 per a especificar propietats espec\u00edfiques d'Hibernate. A partir de Configuration es crear\u00e0 el SessionFactory SessionFactory . Permet construir inst\u00e0ncies Session . Normalment utilitzarem nom\u00e9s un SessionFactory en tota l'aplicaci\u00f3, i d'ell traurem totes les sessions que ens facen falta, a no ser que ens toque accedir a m\u00e9s d'una Base de Dades, on aleshores tindrem una SessionFactory per cada Base de Dades. Session . Com ja hem comentat representa una connexi\u00f3 a la Base de Dades. Query . Permet realitzar consultes a la Base de Dades. El llenguatge utilitzat ser\u00e0 HQL (Hibernate Query Language) o el SQL del SGBD, per\u00f2 preferiblement utilitzarem el primer. Es construeix a partir d'un Session Transaction . Permet assegurar que es fan totes les actualitzacions o cap d'elles. De pas ens assegura que en cas d'error en mig d'una transacci\u00f3, no es fa\u00e7a cap de les operacions. Tamb\u00e9 es construeix a partir d'un Session Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Arquitectura Hibernate"},{"location":"4__arquitectura_hibernate/#4-arquitectura-hibernate","text":"El producte que utilitzarem ser\u00e0 Hibernate . Aquesta eina ens permetr\u00e0 fer el mapatge entre objectes i les taules d'una Base de Dades. Aquestos objectes seran senzills, d'aquells que nom\u00e9s tenen les propietats, i m\u00e8todes get i set per a accedir a elles. Per a intercanviar la informaci\u00f3 entre aquestos objectes i la Base de Dades, utilitzarem la classe Session (que seria l'equivalent de Connection de JDBC). Aquesta classe ens proporciona els m\u00e8todes: save( objecte ) , que guardar\u00e0 l'objecte en la Base de Dades createQuery( consulta ) , que crear\u00e0 una consulta beginTransaction() , que comen\u00e7ar\u00e0 una transacci\u00f3 close() ... Amb a\u00e7\u00f2, interactuar amb la Base de Dades ser\u00e0 molt senzill, i no far\u00e0 falta executar sent\u00e8ncies SQL, tal i com ens passava en JDBC. Session no consumeix molta mem\u00f2ria i la seua creaci\u00f3 i destrucci\u00f3 \u00e9s molt barata, cosa que ens pot animar a crear (i destruir) una sessi\u00f3 per a cada acc\u00e9s a la Base de Dades. Ho anirem veient. El context que ens fa falta per a una aplicaci\u00f3 ser\u00e0: Configuration . S'utilitza per a configurar Hibernate. L'aplicaci\u00f3 utilitza una inst\u00e0ncia de Configuration per a especificar la ubicaci\u00f3 dels documents que descriuen el mapatge i tamb\u00e9 per a especificar propietats espec\u00edfiques d'Hibernate. A partir de Configuration es crear\u00e0 el SessionFactory SessionFactory . Permet construir inst\u00e0ncies Session . Normalment utilitzarem nom\u00e9s un SessionFactory en tota l'aplicaci\u00f3, i d'ell traurem totes les sessions que ens facen falta, a no ser que ens toque accedir a m\u00e9s d'una Base de Dades, on aleshores tindrem una SessionFactory per cada Base de Dades. Session . Com ja hem comentat representa una connexi\u00f3 a la Base de Dades. Query . Permet realitzar consultes a la Base de Dades. El llenguatge utilitzat ser\u00e0 HQL (Hibernate Query Language) o el SQL del SGBD, per\u00f2 preferiblement utilitzarem el primer. Es construeix a partir d'un Session Transaction . Permet assegurar que es fan totes les actualitzacions o cap d'elles. De pas ens assegura que en cas d'error en mig d'una transacci\u00f3, no es fa\u00e7a cap de les operacions. Tamb\u00e9 es construeix a partir d'un Session Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"4 - Arquitectura Hibernate"},{"location":"5__connexi_a_hibernate/","text":"5 - Connexi\u00f3 a Hibernate Des d' IntelliJ Idea no cal cap tipus d'instal\u00b7laci\u00f3. Aix\u00f2 s\u00ed, haurem d'utilitzar la versi\u00f3 ULTIMATE per a poder fer projectes que connecten a Hibernate. Concretament seran projectes de tipus Jakarta EE , que \u00e9s l'evoluci\u00f3 de Java Enterprise , i com d\u00e8iem nom\u00e9s estan disponibles en la versi\u00f3 Ultimate . Durant aquest tema, cada connexi\u00f3 a una Base de Dades la farem en un projecte diferent, al contrari que en temes anteriors, on ho vam col\u00b7locar tot en el mateix projecte. Aquestos projectes seran a m\u00e9s de tipus Maven , que es caracteritzen per no haver d'incorporar les depend\u00e8ncies (Drivers) a m\u00e0, sin\u00f3 que es reflecteixen autom\u00e0ticament en un fixter pom.xml , i ell s'encarrega de baixar tots els drivers necessaris. Ho farem aix\u00ed perqu\u00e8, a difer\u00e8ncia del que hem fet fins ara que hi havia pocs drivers a incorporar, per a Hibernate seran molts .jar, per tant \u00e9s molt m\u00e9s c\u00f2mode un projecte Maven, que ell s'encarregar\u00e0 de baixartots els drivers necessaris Els passos a seguir en cada projecte seran sempre els mateixos: Crear un projecte de tipus Jakarta EE (en versions anterior, Java Enterprise ), amb la implementaci\u00f3 de JPA per Hibernate Crear la connexi\u00f3 a la Base de Dades Afegir la configuraci\u00f3 de persist\u00e8ncia d'Hibernate, per a generar el fitxer hiernate.cfg.xml Mapejar les taules a classes Incorporar el Driver del SGBD a utilitzar (PostgreSQL en l'exemple) Acabar de configurar el fitxer hibernate.cfg.xml El seg\u00fcent v\u00eddeo explica tot el proc\u00e9s de creaci\u00f3 del projecte. Nota En versions anteriors, en el fitxer hibernate.cfg.xml no es guardava usuari ni contrasenya, i despr\u00e9s li feia falta el dialecte de PostgreSQL. Concretament s'havien d'afegir les seg\u00fcents l\u00ednies: <property name=\"connection.username\">geo_ad</property> <property name=\"connection.password\">geo_ad</property> <property name=\"hibernate.dialect\">org.hibernate.dialect.PostgreQL93Dialect</property> I observeu que en aquest exemple hem optat per incorporar el Driver directament, ja que el ten\u00edem des del tema passat. Podr\u00edem haver optat tamb\u00e9 per incorporar-lo a l'estil Maven, que seria senzillament incorporar en el fitxer pom.xml en l'apartat de <dependencies> la seg\u00fcent. Atenci\u00f3: si ja heu incorporat el Driver de PostgreSQL al projecte, no cal que fey el que va a continuaci\u00f3 <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.24</version> </dependency> I aquestes s\u00f3n les dades de connexi\u00f3 a la Base de Dades geo_ad de PostgreSQL : Si la connexi\u00f3 f\u00f3ra a MySQL la BD factura , recordem que les dades de connexi\u00f3 serien: I fins i tot podem mapejar les taules d'una Base de Dades SQLite , amb una connexi\u00f3 com aquesta: 5.1 - HQL: consultes senzilles Podem provar consultes senzilles de HQL, que \u00e9s el llenguatge propi de HQL, paregut a SQL, per\u00f2 utilitzant objectes. Ho podem fer obrint una consola d'Hibernate, des de la finestra de Persist\u00e8ncia, dins de la configuraci\u00f3 d' Hibernate sobre hibernate.cfg.xml , i amb el bot\u00f3 de la dreta triar Console S'obrir\u00e0 un apartat a la part de baix, i com que la connexi\u00f3 \u00e9s sobre la que hav\u00edem fet en la Base de Dades, si en la finestra Database estem connectats, podrem fer les consultes HQL . La primera podria ser aquesta from Comarca . Hem de respectar escrupulosament maj\u00fascules i min\u00fascules, ja que en definitiva estem accedint a les classes Java. 5.2 - Comen\u00e7ant a programar Com que hem fet un projecte Maven, totes les llibreries necess\u00e0ries estaran ja incorporades. I si ja hem incorporat el Driver de PostgreSQL, b\u00e9 directament tal com feem en el Tema 4, b\u00e9 incorporant la depend\u00e8ncia en el fitxer pom.xml, aleshores ja estem en condicions de comen\u00e7ar a programar. Tots els programes que farem, els posarem dins del paquet exemples , que ha d'estar dins de src - > main -> kotlin . Aquest primer programa el podem guardar amb el nom Exemple_01_PrimerAcces.kt : package exemples import org.hibernate.cfg.Configuration import classes.Comarca fun main(args: Array<String>) { val sf = Configuration().configure().buildSessionFactory() val sessio = sf.openSession() val com = sessio.get(\"classes.Comarca\", \"Alt Maestrat\") as Comarca print(\"Comarca \" + com.nomC + \": \") print(com.provincia) println(\" (\" + com.poblacions.size + \" pobles)\") sessio.close() } L'execuci\u00f3 ens haur\u00e0 donat molts avisos, que s\u00f3n un poc pesats, per\u00f2 l'execuci\u00f3 (la l\u00ednia en negre quasi al final) ha eixit b\u00e9 El programa a carregat la comarca de l'Alt Maestrat, i ens ha dit la prov\u00edncia i el n\u00famero de pobles Anem a llevar aquetsos missatge, que s\u00f3n \u00fanicament de INFO. Senzillament li direm que mostre \u00fanicament els errors severs . LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) Aprofitarem per a canviar un poc el programa, i ara traurem tamb\u00e9 el nom dels pobles de la comarca Alt Maestrat. Aix\u00ed veiem tamb\u00e9 el potencial, ja que \u00e9s comod\u00edssim accedir els pobles de la comarca. Guardeu el seg\u00fcent programa amb el nom Exemple_02_SegonAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alt Maestrat\") as Comarca print(\"Comarca \" + com.nomC + \": \") print(com.provincia) println(\" (\" + com.poblacions.size + \" pobles)\") for (p in com.poblacions) println(\"\\t\" + p.nom) sessio.close() } I aquest ser\u00e0 el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5 - Connexi\u00f3 a Hibernate"},{"location":"5__connexi_a_hibernate/#5-connexio-a-hibernate","text":"Des d' IntelliJ Idea no cal cap tipus d'instal\u00b7laci\u00f3. Aix\u00f2 s\u00ed, haurem d'utilitzar la versi\u00f3 ULTIMATE per a poder fer projectes que connecten a Hibernate. Concretament seran projectes de tipus Jakarta EE , que \u00e9s l'evoluci\u00f3 de Java Enterprise , i com d\u00e8iem nom\u00e9s estan disponibles en la versi\u00f3 Ultimate . Durant aquest tema, cada connexi\u00f3 a una Base de Dades la farem en un projecte diferent, al contrari que en temes anteriors, on ho vam col\u00b7locar tot en el mateix projecte. Aquestos projectes seran a m\u00e9s de tipus Maven , que es caracteritzen per no haver d'incorporar les depend\u00e8ncies (Drivers) a m\u00e0, sin\u00f3 que es reflecteixen autom\u00e0ticament en un fixter pom.xml , i ell s'encarrega de baixar tots els drivers necessaris. Ho farem aix\u00ed perqu\u00e8, a difer\u00e8ncia del que hem fet fins ara que hi havia pocs drivers a incorporar, per a Hibernate seran molts .jar, per tant \u00e9s molt m\u00e9s c\u00f2mode un projecte Maven, que ell s'encarregar\u00e0 de baixartots els drivers necessaris Els passos a seguir en cada projecte seran sempre els mateixos: Crear un projecte de tipus Jakarta EE (en versions anterior, Java Enterprise ), amb la implementaci\u00f3 de JPA per Hibernate Crear la connexi\u00f3 a la Base de Dades Afegir la configuraci\u00f3 de persist\u00e8ncia d'Hibernate, per a generar el fitxer hiernate.cfg.xml Mapejar les taules a classes Incorporar el Driver del SGBD a utilitzar (PostgreSQL en l'exemple) Acabar de configurar el fitxer hibernate.cfg.xml El seg\u00fcent v\u00eddeo explica tot el proc\u00e9s de creaci\u00f3 del projecte. Nota En versions anteriors, en el fitxer hibernate.cfg.xml no es guardava usuari ni contrasenya, i despr\u00e9s li feia falta el dialecte de PostgreSQL. Concretament s'havien d'afegir les seg\u00fcents l\u00ednies: <property name=\"connection.username\">geo_ad</property> <property name=\"connection.password\">geo_ad</property> <property name=\"hibernate.dialect\">org.hibernate.dialect.PostgreQL93Dialect</property> I observeu que en aquest exemple hem optat per incorporar el Driver directament, ja que el ten\u00edem des del tema passat. Podr\u00edem haver optat tamb\u00e9 per incorporar-lo a l'estil Maven, que seria senzillament incorporar en el fitxer pom.xml en l'apartat de <dependencies> la seg\u00fcent. Atenci\u00f3: si ja heu incorporat el Driver de PostgreSQL al projecte, no cal que fey el que va a continuaci\u00f3 <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <version>42.2.24</version> </dependency> I aquestes s\u00f3n les dades de connexi\u00f3 a la Base de Dades geo_ad de PostgreSQL : Si la connexi\u00f3 f\u00f3ra a MySQL la BD factura , recordem que les dades de connexi\u00f3 serien: I fins i tot podem mapejar les taules d'una Base de Dades SQLite , amb una connexi\u00f3 com aquesta:","title":"5 - Connexi\u00f3 a Hibernate"},{"location":"5__connexi_a_hibernate/#51-hql-consultes-senzilles","text":"Podem provar consultes senzilles de HQL, que \u00e9s el llenguatge propi de HQL, paregut a SQL, per\u00f2 utilitzant objectes. Ho podem fer obrint una consola d'Hibernate, des de la finestra de Persist\u00e8ncia, dins de la configuraci\u00f3 d' Hibernate sobre hibernate.cfg.xml , i amb el bot\u00f3 de la dreta triar Console S'obrir\u00e0 un apartat a la part de baix, i com que la connexi\u00f3 \u00e9s sobre la que hav\u00edem fet en la Base de Dades, si en la finestra Database estem connectats, podrem fer les consultes HQL . La primera podria ser aquesta from Comarca . Hem de respectar escrupulosament maj\u00fascules i min\u00fascules, ja que en definitiva estem accedint a les classes Java.","title":"5.1 - HQL: consultes senzilles"},{"location":"5__connexi_a_hibernate/#52-comencant-a-programar","text":"Com que hem fet un projecte Maven, totes les llibreries necess\u00e0ries estaran ja incorporades. I si ja hem incorporat el Driver de PostgreSQL, b\u00e9 directament tal com feem en el Tema 4, b\u00e9 incorporant la depend\u00e8ncia en el fitxer pom.xml, aleshores ja estem en condicions de comen\u00e7ar a programar. Tots els programes que farem, els posarem dins del paquet exemples , que ha d'estar dins de src - > main -> kotlin . Aquest primer programa el podem guardar amb el nom Exemple_01_PrimerAcces.kt : package exemples import org.hibernate.cfg.Configuration import classes.Comarca fun main(args: Array<String>) { val sf = Configuration().configure().buildSessionFactory() val sessio = sf.openSession() val com = sessio.get(\"classes.Comarca\", \"Alt Maestrat\") as Comarca print(\"Comarca \" + com.nomC + \": \") print(com.provincia) println(\" (\" + com.poblacions.size + \" pobles)\") sessio.close() } L'execuci\u00f3 ens haur\u00e0 donat molts avisos, que s\u00f3n un poc pesats, per\u00f2 l'execuci\u00f3 (la l\u00ednia en negre quasi al final) ha eixit b\u00e9 El programa a carregat la comarca de l'Alt Maestrat, i ens ha dit la prov\u00edncia i el n\u00famero de pobles Anem a llevar aquetsos missatge, que s\u00f3n \u00fanicament de INFO. Senzillament li direm que mostre \u00fanicament els errors severs . LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) Aprofitarem per a canviar un poc el programa, i ara traurem tamb\u00e9 el nom dels pobles de la comarca Alt Maestrat. Aix\u00ed veiem tamb\u00e9 el potencial, ja que \u00e9s comod\u00edssim accedir els pobles de la comarca. Guardeu el seg\u00fcent programa amb el nom Exemple_02_SegonAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alt Maestrat\") as Comarca print(\"Comarca \" + com.nomC + \": \") print(com.provincia) println(\" (\" + com.poblacions.size + \" pobles)\") for (p in com.poblacions) println(\"\\t\" + p.nom) sessio.close() } I aquest ser\u00e0 el resultat: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"5.2 - Comen\u00e7ant a programar"},{"location":"6__classes_generades/","text":"6 - Classes generades Comentem les classe que ha generat autom\u00e0ticament Hibernate. S\u00f3n classes Java . Podr\u00edem traduir-les perfectament a Kotlin. Per\u00f2 optarem per no canviar-les per fer el proc\u00e9s m\u00e9s senzill. Posar\u00e0 una propietat per cada camp de la taula, i alguna cosa m\u00e9s com veurem m\u00e9s endavant. Tamb\u00e9 posar\u00e0 un m\u00e8tode get i un set per a cada propietat, ja que les propietats seran private . A continuaci\u00f3 mostrem 2 de les classes. En el cas de Poblacio.java no hem posat tots els m\u00e8todes get i set , ja que sempre s\u00f3n com cabria esperar. I en roig teniu el m\u00e9s destacable. Sens dubte, el m\u00e9s destacable de la classe Comarca \u00e9s que en les propietats, posa tamb\u00e9 una col\u00b7lecci\u00f3 d'objectes Poblacio . A\u00e7\u00f2 ens permetr\u00e0 accedir comod\u00edssimament a les poblacions d'una determinada comarca. Aquest conjunt sempre l'intenta anomenar com la classe a qu\u00e8 fa refer\u00e8ncia, per\u00f2 en plural (en el nostre cas seria poblacios ) encara que en el moment de dissenyar el mapatge podem canviar aquest nom. Una col\u00b7lacci\u00f3 ( Collection ) t\u00e9 un comportament relativament senzill per a accedir als seus elements. En la classe Poblacio , tindrem les propietats que cabria esperar. I la refer\u00e8ncia a la comarca \u00e9s un objecte de la classe Comarca . Tamb\u00e9 tindr\u00e0 un conjunt d'objectes Institut . Per tant, i en resum, una cosa molt \u00fatil que fa Hibernate quan troba una clau externa, \u00e9s posar en la classe corresponent a la taula on est\u00e0 la clau externa una propietat de la classe corresponent a la taula principal (cosa que en principi cabria esperar); per\u00f2 tamb\u00e9 en la classe corresponent a la taula principal, un conjunt d'objectes de la classe corresponent a l'altra taula, la qual cosa ens permetr\u00e0 accedir f\u00e0cilment. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"6 - Classes generades"},{"location":"6__classes_generades/#6-classes-generades","text":"Comentem les classe que ha generat autom\u00e0ticament Hibernate. S\u00f3n classes Java . Podr\u00edem traduir-les perfectament a Kotlin. Per\u00f2 optarem per no canviar-les per fer el proc\u00e9s m\u00e9s senzill. Posar\u00e0 una propietat per cada camp de la taula, i alguna cosa m\u00e9s com veurem m\u00e9s endavant. Tamb\u00e9 posar\u00e0 un m\u00e8tode get i un set per a cada propietat, ja que les propietats seran private . A continuaci\u00f3 mostrem 2 de les classes. En el cas de Poblacio.java no hem posat tots els m\u00e8todes get i set , ja que sempre s\u00f3n com cabria esperar. I en roig teniu el m\u00e9s destacable. Sens dubte, el m\u00e9s destacable de la classe Comarca \u00e9s que en les propietats, posa tamb\u00e9 una col\u00b7lecci\u00f3 d'objectes Poblacio . A\u00e7\u00f2 ens permetr\u00e0 accedir comod\u00edssimament a les poblacions d'una determinada comarca. Aquest conjunt sempre l'intenta anomenar com la classe a qu\u00e8 fa refer\u00e8ncia, per\u00f2 en plural (en el nostre cas seria poblacios ) encara que en el moment de dissenyar el mapatge podem canviar aquest nom. Una col\u00b7lacci\u00f3 ( Collection ) t\u00e9 un comportament relativament senzill per a accedir als seus elements. En la classe Poblacio , tindrem les propietats que cabria esperar. I la refer\u00e8ncia a la comarca \u00e9s un objecte de la classe Comarca . Tamb\u00e9 tindr\u00e0 un conjunt d'objectes Institut . Per tant, i en resum, una cosa molt \u00fatil que fa Hibernate quan troba una clau externa, \u00e9s posar en la classe corresponent a la taula on est\u00e0 la clau externa una propietat de la classe corresponent a la taula principal (cosa que en principi cabria esperar); per\u00f2 tamb\u00e9 en la classe corresponent a la taula principal, un conjunt d'objectes de la classe corresponent a l'altra taula, la qual cosa ens permetr\u00e0 accedir f\u00e0cilment. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"6 - Classes generades"},{"location":"7__estructura_dels_fitxers_de_mapatge/","text":"7 - Estructura dels fitxers de mapatge En la pregunta 5.1 hav\u00edem vist les classes generades per Hibernate. Anem a veure-ho ara amb m\u00e9s detall, mirant totes les classes i fitxers generades en el proc\u00e9s de mapatge i com s'interrelacionen entre elles. Els fitxers que serveixen de mapatge, Hibernate els genera de tipus XML , i seran: hibernate.cfg.xml , ja comentat anteriorment i que estableix les condicions b\u00e0siques de la connexi\u00f3 amb la Base de Dades (Driver, URL, usuari, contrasenya, ...). Un fitxer .hbm.xml per cada taula (i classe). Aix\u00ed en el nostre exemple tindrem Comarques.hbm.xml , Poblacions.hbm.xml i Instituts.hbm.xml i s\u00f3n els encarregats de dir la correspond\u00e8ncia entre els camps de la taula (p.e. COMARCA) i les propietats de l'objecte (p.e. Comarca.java). La seg\u00fcent imatge explica aquesta manera d'enlla\u00e7ar. Les nostre classes s\u00f3n classes Kotlin, per\u00f2 totalment equivalents a les classes Java, per aix\u00f2 es deixa aquest nom en la imatge: El fitxer hibernate.cfg.xml El fitxer hibernate.cfg.xml estableix les condicions de la connexi\u00f3. Depenent de la versi\u00f3, pot estar lleugerament diferent: <?xml version='1.0' encoding='utf-8'?> <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"connection.url\">jdbc:postgresql://89.36.214.106:5432/geo_ad</property> <property name=\"connection.driver_class\">org.postgresql.Driver</property> <property name=\"connection.username\">geo_ad</property> <property name=\"connection.password\">geo_ad</property> <property name=\"hibernate.dialect\">org.hibernate.dialect.PostgreSQL93Dialect</property> <mapping resource=\"Comarca.hbm.xml\"/> <mapping resource=\"Institut.hbm.xml\"/> <mapping resource=\"Poblacio.hbm.xml\"/> </session-factory> </hibernate-configuration> Podem observar com s'especifica el driver JDBC, la URL, l'usuari que es connecta, la contrasenya i el dialecte (per a poder comunicar-se b\u00e9 en versions anteriors). Tamb\u00e9 ha registrat els fitxers de mapatge. Els fitxers .hbm.xml Els fitxers .hbm.xml estableixen la correspond\u00e8ncia entre taula i classe, i dins d'elles entre camps de la taula i propietats de la classe. Mirem el contingut de Comarques.hbm.xml . Posem a un costat l'estructura de la taula, i a l'altre l'estructura de l'objecte: Comentem un poc les coses: < hibernate-mapping> \u00e9s l'element arrel; tot el mapatge est\u00e0 contingut dins d'ell. < class> Equival a tota la classe per una banda i tota la taula per una altra. Dins d'aquest element estaran totes les correspond\u00e8ncies de camps i propietats. L'atribut name cont\u00e9 el nom de la classe. L'atribut table cont\u00e9 el nom de la taula corresponent. Pot haver algun altre atribut, indicant el cat\u00e0leg (dep\u00e9n del SGBD) < id> especifica el camp que \u00e9s clau principal. \u00c9s diferent als camps normals. L'atribut name indica el nom de la propietat L'atribut * *column indica el camp de la taula < property> especifica un camp normal, que no \u00e9s clau principal. Nom\u00e9s s'ha d'especificar: L'atribut name indica el nom de la propietat L'atribut column indica el camp de la taula I ens deixem per al final la manera d'enlla\u00e7ar la clau externa. Recordem que la clau externa est\u00e0 definida en POBLACIO i que apunta a COMARCA . En el mapatge de Comarca tindrem una l\u00ednia nova que \u00e9s la que indica que la propietat poblacions ha de contenir les poblacions de la comarca. \u00c9s per tant un conjunt ( Collection ) de moltes poblacions. Les coses m\u00e9s importants s\u00f3n les seg\u00fcents: < set> que indica que ser\u00e0 un conjunt L'atribut name ser\u00e0 el nom de la propietat L'element key especifica la clau externa, amb l'element column i atribut name , en aquest cas nom_c . L'element one-to-many indica que un departament pot tenir molts empleats (per aix\u00f2 era un conjunt), i especifica de quina classe s\u00f3n amb l'atribut class En el cas de les poblacions, taula POBLACIO i classe Poblacio , les coses seran molt similars. La difer\u00e8ncia m\u00e9s significativa \u00e9s la manera de representar la clau externa. Ara ser\u00e0 una relaci\u00f3 many-to-one , indicant que la poblaci\u00f3 pot estar en una \u00fanica comarca, \u00e9s a dir far\u00e0 refer\u00e8ncia a un \u00fanic objecte Comarca . <many-to-one name=\"comarca\" class=\"classes.Comarca\"> <column name=\"nom_c\" not-null=\"true\"/> </many-to-one> < many-to-one > en la propietat que fa refer\u00e8ncia a l'altra classe L'atribut name indica el nom de la propietat. L'atribut class indica la classe a qu\u00e8 fa refer\u00e8ncia, en aquest cas Comarca . L'element column \u00e9s un element buit amb la propietat name , que contindr\u00e0 el camp de la taula En resum, dins de l'element class que equival a la classe (i la taula), tindrem els elements : id per a la clau principal property per als camps normals set per als que s\u00f3n apuntats per una clau externa, indicant el conjunt. many-to-one per als que s\u00f3n clau externa**** 7.1 - Anotacions en compte de fitxers xml de mpatge Ja vam comentar en la pregunta 3 que hi havia 2 t\u00e8cniques per a fer el mapatge: Per mig de fitxers xml , que s\u00f3n els que hem vist Per mig d' anotacions Les anotacions es fan en el mateix fitxer on est\u00e0 definida la classe que ens ha resultat (Comarca.java, Poblacio.java i Institut.java), per\u00f2 per a que Java no ho intente interpretar, en fan amb un s\u00edmbol inicial i aix\u00ed distingir les anotacions de les l\u00ednies normals de la classe. Aquest car\u00e0cter especial pel qual comencen les anotacions sol ser @ Aquest seria el resultat de la classe amb anotacions, si hagu\u00e9rem optat per aquesta t\u00e8cnica. Es mostra nom\u00e9s a nivell il\u00b7lustratiu. Vosaltres no ho tindreu en el vostre projecte package classes; import javax.persistence.*; import java.util.Collection; @Entity public class Comarca { private String nomC; private String provincia; private Collection<Poblacio> poblacions; @Id @Column(name = \"nom_c\") public String getNomC() { return nomC; } public void setNomC(String nomC) { this.nomC = nomC; } @Basic @Column(name = \"provincia\") public String getProvincia() { return provincia; } public void setProvincia(String provincia) { this.provincia = provincia; } @Override public boolean equals(Object o) { ... } @Override public int hashCode() { ... } @OneToMany(mappedBy = \"comarca\") public Collection<Poblacio> getPoblacions() { return poblacions; } public void setPoblacions(Collection<Poblacio> poblacions) { this.poblacions = poblacions; } } Observeu com tenim les mateixes coses que en els fitxers de mapatge, per\u00f2 representat de forma lleugerament diferent Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"7 - Estructura dels fitxers de mapatge"},{"location":"7__estructura_dels_fitxers_de_mapatge/#7-estructura-dels-fitxers-de-mapatge","text":"En la pregunta 5.1 hav\u00edem vist les classes generades per Hibernate. Anem a veure-ho ara amb m\u00e9s detall, mirant totes les classes i fitxers generades en el proc\u00e9s de mapatge i com s'interrelacionen entre elles. Els fitxers que serveixen de mapatge, Hibernate els genera de tipus XML , i seran: hibernate.cfg.xml , ja comentat anteriorment i que estableix les condicions b\u00e0siques de la connexi\u00f3 amb la Base de Dades (Driver, URL, usuari, contrasenya, ...). Un fitxer .hbm.xml per cada taula (i classe). Aix\u00ed en el nostre exemple tindrem Comarques.hbm.xml , Poblacions.hbm.xml i Instituts.hbm.xml i s\u00f3n els encarregats de dir la correspond\u00e8ncia entre els camps de la taula (p.e. COMARCA) i les propietats de l'objecte (p.e. Comarca.java). La seg\u00fcent imatge explica aquesta manera d'enlla\u00e7ar. Les nostre classes s\u00f3n classes Kotlin, per\u00f2 totalment equivalents a les classes Java, per aix\u00f2 es deixa aquest nom en la imatge: El fitxer hibernate.cfg.xml El fitxer hibernate.cfg.xml estableix les condicions de la connexi\u00f3. Depenent de la versi\u00f3, pot estar lleugerament diferent: <?xml version='1.0' encoding='utf-8'?> <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <session-factory> <property name=\"connection.url\">jdbc:postgresql://89.36.214.106:5432/geo_ad</property> <property name=\"connection.driver_class\">org.postgresql.Driver</property> <property name=\"connection.username\">geo_ad</property> <property name=\"connection.password\">geo_ad</property> <property name=\"hibernate.dialect\">org.hibernate.dialect.PostgreSQL93Dialect</property> <mapping resource=\"Comarca.hbm.xml\"/> <mapping resource=\"Institut.hbm.xml\"/> <mapping resource=\"Poblacio.hbm.xml\"/> </session-factory> </hibernate-configuration> Podem observar com s'especifica el driver JDBC, la URL, l'usuari que es connecta, la contrasenya i el dialecte (per a poder comunicar-se b\u00e9 en versions anteriors). Tamb\u00e9 ha registrat els fitxers de mapatge. Els fitxers .hbm.xml Els fitxers .hbm.xml estableixen la correspond\u00e8ncia entre taula i classe, i dins d'elles entre camps de la taula i propietats de la classe. Mirem el contingut de Comarques.hbm.xml . Posem a un costat l'estructura de la taula, i a l'altre l'estructura de l'objecte: Comentem un poc les coses: < hibernate-mapping> \u00e9s l'element arrel; tot el mapatge est\u00e0 contingut dins d'ell. < class> Equival a tota la classe per una banda i tota la taula per una altra. Dins d'aquest element estaran totes les correspond\u00e8ncies de camps i propietats. L'atribut name cont\u00e9 el nom de la classe. L'atribut table cont\u00e9 el nom de la taula corresponent. Pot haver algun altre atribut, indicant el cat\u00e0leg (dep\u00e9n del SGBD) < id> especifica el camp que \u00e9s clau principal. \u00c9s diferent als camps normals. L'atribut name indica el nom de la propietat L'atribut * *column indica el camp de la taula < property> especifica un camp normal, que no \u00e9s clau principal. Nom\u00e9s s'ha d'especificar: L'atribut name indica el nom de la propietat L'atribut column indica el camp de la taula I ens deixem per al final la manera d'enlla\u00e7ar la clau externa. Recordem que la clau externa est\u00e0 definida en POBLACIO i que apunta a COMARCA . En el mapatge de Comarca tindrem una l\u00ednia nova que \u00e9s la que indica que la propietat poblacions ha de contenir les poblacions de la comarca. \u00c9s per tant un conjunt ( Collection ) de moltes poblacions. Les coses m\u00e9s importants s\u00f3n les seg\u00fcents: < set> que indica que ser\u00e0 un conjunt L'atribut name ser\u00e0 el nom de la propietat L'element key especifica la clau externa, amb l'element column i atribut name , en aquest cas nom_c . L'element one-to-many indica que un departament pot tenir molts empleats (per aix\u00f2 era un conjunt), i especifica de quina classe s\u00f3n amb l'atribut class En el cas de les poblacions, taula POBLACIO i classe Poblacio , les coses seran molt similars. La difer\u00e8ncia m\u00e9s significativa \u00e9s la manera de representar la clau externa. Ara ser\u00e0 una relaci\u00f3 many-to-one , indicant que la poblaci\u00f3 pot estar en una \u00fanica comarca, \u00e9s a dir far\u00e0 refer\u00e8ncia a un \u00fanic objecte Comarca . <many-to-one name=\"comarca\" class=\"classes.Comarca\"> <column name=\"nom_c\" not-null=\"true\"/> </many-to-one> < many-to-one > en la propietat que fa refer\u00e8ncia a l'altra classe L'atribut name indica el nom de la propietat. L'atribut class indica la classe a qu\u00e8 fa refer\u00e8ncia, en aquest cas Comarca . L'element column \u00e9s un element buit amb la propietat name , que contindr\u00e0 el camp de la taula En resum, dins de l'element class que equival a la classe (i la taula), tindrem els elements : id per a la clau principal property per als camps normals set per als que s\u00f3n apuntats per una clau externa, indicant el conjunt. many-to-one per als que s\u00f3n clau externa****","title":"7 - Estructura dels fitxers de mapatge"},{"location":"7__estructura_dels_fitxers_de_mapatge/#71-anotacions-en-compte-de-fitxers-xml-de-mpatge","text":"Ja vam comentar en la pregunta 3 que hi havia 2 t\u00e8cniques per a fer el mapatge: Per mig de fitxers xml , que s\u00f3n els que hem vist Per mig d' anotacions Les anotacions es fan en el mateix fitxer on est\u00e0 definida la classe que ens ha resultat (Comarca.java, Poblacio.java i Institut.java), per\u00f2 per a que Java no ho intente interpretar, en fan amb un s\u00edmbol inicial i aix\u00ed distingir les anotacions de les l\u00ednies normals de la classe. Aquest car\u00e0cter especial pel qual comencen les anotacions sol ser @ Aquest seria el resultat de la classe amb anotacions, si hagu\u00e9rem optat per aquesta t\u00e8cnica. Es mostra nom\u00e9s a nivell il\u00b7lustratiu. Vosaltres no ho tindreu en el vostre projecte package classes; import javax.persistence.*; import java.util.Collection; @Entity public class Comarca { private String nomC; private String provincia; private Collection<Poblacio> poblacions; @Id @Column(name = \"nom_c\") public String getNomC() { return nomC; } public void setNomC(String nomC) { this.nomC = nomC; } @Basic @Column(name = \"provincia\") public String getProvincia() { return provincia; } public void setProvincia(String provincia) { this.provincia = provincia; } @Override public boolean equals(Object o) { ... } @Override public int hashCode() { ... } @OneToMany(mappedBy = \"comarca\") public Collection<Poblacio> getPoblacions() { return poblacions; } public void setPoblacions(Collection<Poblacio> poblacions) { this.poblacions = poblacions; } } Observeu com tenim les mateixes coses que en els fitxers de mapatge, per\u00f2 representat de forma lleugerament diferent Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"7.1 - Anotacions en compte de fitxers xml de mpatge"},{"location":"8__sessions_i_objectes_hibernate/","text":"8 - Sessions i objectes hibernate En aquesta secci\u00f3 comentarem el comportament de les sessions i dels objectes Hibernate (les classes creades per Hibernate). Recordem que el proc\u00e9s per a arribar a una sessi\u00f3 era Configuration - > SessionFactory -> Session . Les sent\u00e8ncies serien aquestes: val cfg = Configuration().configure() val sf = cfg.buildSessionFactory() val sessio = sf.openSession() La primera sent\u00e8ncia carrega el fitxer de configuraci\u00f3 hibernate.cfg.xml , i inicialitza l'entorn d'Hibernate. A partir d'aquest moment podem utilitzar l'objecte Configuration per crear el SessionFactory . 8.1 - Transaccions El primer que haur\u00edem de fer notar \u00e9s que si el SGBD admet transaccions, les possibles modificacions que fem sobre una Base de Dades a trav\u00e9s d'Hibernate no es guardaran si no posem en marxa una transacci\u00f3. Per tant, si volem fer actualitzacions (insercions, esborrats i/o modificacions), el primer que haurem de fer en la sessi\u00f3 ser\u00e0 comen\u00e7ar una transacci\u00f3. Al final podrem confirmar amb commit o rebutjar totes les actualitzacions amb rollback . En el seg\u00fcent codi inserim una nova comarca. Utilitzem el m\u00e8tode save de la sessi\u00f3, per\u00f2 ja el veurem m\u00e9s avant. Ara nom\u00e9s volem il\u00b7lustrar una transacci\u00f3. No farem aquest exemple, ja que tots ens estem connectant com el mateix usuari a la mateixa Base de Dades, aleshores nom\u00e9s el primer ho podria fer, i a la reste ens donaria error perqu\u00e8 ja existiria la fila corresponent a aquesta nova comarca (restricci\u00f3 de clau principal) 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 val t = sessio.beginTransaction() 3 4 val com = Comarca() 5 com.nomC = \"Columbretes\" 6 com.provincia = \"Castell\u00f3\" 7 sessio.save(com) 8 9 t.commit() 10 sessio.close() En cas de no haver posat les dues sent\u00e8ncies de les l\u00ednies 2 i 9, no hauria hagut cap modificaci\u00f3. El m\u00e8tode beginTransaction() ha fet comen\u00e7ar la transacci\u00f3, i el m\u00e8tode commit() l'ha confirmada definitivament. Si en aquest moment vulgu\u00e9rem comen\u00e7ar una altra transacci\u00f3 seria suficient amb t.begin() . Per a no haver d'estar sempre pendents de transaccions, es podria posar en mode autocommit , \u00e9s a dir, que autom\u00e0ticament fa\u00e7a un commit despr\u00e9s de cada actualitzaci\u00f3 (despr\u00e9s de cada save() , delete() o update() ). Seria canviar en el fitxer hibernate.cfg.xml , posant la seg\u00fcent propietat entre les del < session-factory> : <property name=\"hibernate.connection.autocommit\">true</property> Tanmateix no \u00e9s tan fiable, i us recomane que utilitzeu transaccions, \u00e9s a dir, tenir el autocommit a false com estava per defecte i gestionar les transaccions manualment. 8.2 - Estats d'un objecte Hibernate Els objectes de les classes que Hibernate ens ha ajudat a crear poden estar en m\u00e9s d'un estat, si mirem la seua sincronitzaci\u00f3 amb la Base de Dades: Transitori : quan l'objecte s'ha creat, per\u00f2 no s'ha associat a cap sessi\u00f3. \u00c9s a dir, ja s'ha creat amb la creaci\u00f3 de l'objecte i potser estiga buit o no (ja se li ha posat algun valor a alguna propietat), per\u00f2 encara no s'ha associat a cap sessi\u00f3. Es podr\u00e0 associar per exemple amb save() per a guardar l'objecte com hem vist en l'exemple de l'apartat anterior, o per exemple amb load() , com hav\u00edem vist en exemples anteriors per a agafar des de la Base de Dades. Persistent : quan l'objecte ja s'ha associat amb una sessi\u00f3 i per tant t\u00e9 una representaci\u00f3 en la Base de Dades i un valor identificador. Es pot haver guardat o carregat. Hibernate detectar\u00e0 qualsevol canvi fet sobre un objecte persistent i sincronitzar\u00e0 l'estat quan es complete la unitat de treball. I per a aix\u00f2 ja s'encarregar\u00e0 ell de fer els INSERT, DELETE o UPDATE en la Base de Dades. Nosaltres no ens haurem de preocupar. Separat : \u00e9s un objecte persistent, per\u00f2 que la seua sessi\u00f3 ha finalitzat. Es pot utilitzar, i fins i tot canviar l'estat, per\u00f2 no tindr\u00e0 efecte aquestos canvies la Base de Dades, a no ser que es torne a associar una altra vegada amb una sessi\u00f3, \u00e9s a dir, si es torna a fer persistent. De fet, \u00e9s una t\u00e8cnica de treball, utilitzar objectes separats quan l'usuari puga estar molt de temps sense interactuar, i quan torne a interactuar, tornar a fer-lo persistent. Anem a veure un exemple on es vegen els tres tipus d'estat. Tampoc cal que el feu vosaltres, est\u00e0 \u00fanicament a nivell il\u00b7lustratiu: val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = Comarca() // A partir d'ac\u00ed l'objecte \u00e9s transitori com.nomC = \"Columbretes\" com.provincia = \"Castell\u00f3\" sessio.save(com) // A partir d'ac\u00ed \u00e9s persistent t.commit() sessio.close() // A partir d'ac\u00ed \u00e9s separat, igual es pot utilitzar, // per\u00f2 no estar\u00e0 sincronitzat println(com.nomC + \" (\" + com.provincia + \")\") 8.3 - C\u00e0rrega d'objectes: m\u00e8todes load() i get() La c\u00e0rrega d'objectes s'aconsegueix amb els m\u00e8todes load() i get() . S\u00f3n similars excepte en una q\u00fcesti\u00f3: el primer d\u00f3na un error si no es troba la fila, mentre que el segon contindr\u00e0 null. A m\u00e9s a partir d'Hibernate 6.0 load est\u00e0 deprecated , aix\u00ed que millor uilitzar get . Tant si utilitzem un com l'altre, haurem d'especificar 2 par\u00e0metres: la classe que volem buscar, i el valor de la clau principal de qui volem trobar. Aquest valor s'ha de passar amb el mateix tipus que la propietat corresponent a la clau principal , i en moltes ocasions haurem de canviar de tipus ( cast ). En el seg\u00fcent exemple, molt paregut al ja utilitzat anteriorment en SegonAcces , trobem la comarca Alt Maestrat (valor de nom_c , que correspon a la clau principal). En aquesta ocasi\u00f3 no cal canviar de tipus, ja que \u00e9s string: 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 3 val com = sessio.get(\"classes.Comarca\",\"Alt Maestrat\") as Comarca // c\u00e0rrega amb m\u00e8tode load() 4 5 println(\"Comarca \" + com.nomC + \": \" + com.provincia) 6 sessio.close() Com coment\u00e0vem, si no existira la comarca Alt Maestrat, donaria un error. Ac\u00ed tenim el mateix exemple, per\u00f2 utilitzant el m\u00e8tode get() i comprovant despr\u00e9s si com \u00e9s null, i aix\u00ed esquivem l'error: 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 3 val com = sessio.get(\"classes.Comarca\",\"Al Maestrat\") as Comarca? // c\u00e0rrega amb m\u00e8tode get() 4 5 if (com==null) 6 println(\"No existeix la comarca\"); 7 else { 8 println(\"Comarca \" + com.nomC + \": \" + com.provincia) 9 } 10 sessio.close() Nom\u00e9s hem tingut la dificultat d'haver de posar Comarca? per si \u00e9s null el resultat de la consulta (justament el que volem comprovar) Anem a mirar la potencialitat que ens proporciona la manera que t\u00e9 Hibernate de construir les classes, amb el conjunt (o col\u00b7lecci\u00f3) de poblacions que t\u00e9 un objecte de la classe Comarca. Els Set es poden rec\u00f3rrer de m\u00e9s d'una manera. Una molt estesa \u00e9s utilitzar un iterator , utilitzant els m\u00e8todes hasNext() que ens diu si hi ha m\u00e9s elements en la col\u00b7lecci\u00f3, i next() que torna el seg\u00fcent element de la col\u00b7lecci\u00f3. En el seg\u00fcent programa anem a visualitzar informaci\u00f3 de la comarca de l' Alcalat\u00e9n , i tamb\u00e9 els seus pobles. Estan marcades les l\u00ednies de la utilitzaci\u00f3 del Iterator . Copieu-lo en un fitxer Kotlin anomenat Exemple_03_TercerAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alcalat\u00e9n\") as Comarca print(\"La comarca \" + com.nomC) print(\" (prov\u00edncia de \" + com.provincia + \") \") println(\"t\u00e9 \" + com.poblacions.size + \" pobles\") println() println(\"Llista de pobles\") println(\"-----------------\") val it = com.poblacions.iterator()!! while (it.hasNext()) { val p = it.next() System.out.println(p.nom + \" (\" + p.poblacio + \" habitants)\") } sessio.close() } Per\u00f2 m\u00e9s senzilla encara \u00e9s la utilitzaci\u00f3 del bucle foreach , que fa el recorregut ell sol, tenint disponible cada element. La sintaxi en Kotlin pot ser de dues maneres. Posem com queda l'exemple anterior de cadascuna de les dues maneres for ( e in conjunt ) i e anir\u00e0 agafant tots els valors de la col\u00b7lecci\u00f3. for (p in com.poblacions!!) { println(p.nom + \" (\" + p.poblacio + \" habitants)\") } conjunt. forEach() i dins dels par\u00e8ntesis utilitzem cada element com it com.poblacions!!.forEach { println(it.nom + \" (\" + it.poblacio + \" habitants)\") } Utilitzarem la primera forma, que \u00e9s la m\u00e9s c\u00f2moda, i quedar\u00e0 de la seg\u00fcent manera. Guardeu el seg\u00fcent programa en fitxer Kotlin anomenat Exemple_04_QuartAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alcalat\u00e9n\") as Comarca print(\"La comarca \" + com.nomC) print(\" (prov\u00edncia de \" + com.provincia + \") \") println(\"t\u00e9 \" + com.poblacions.size + \" pobles\") println() println(\"Llista de pobles\") println(\"-----------------\") for (p in com.poblacions) { println(p.nom + \" (\" + p.poblacio + \" habitants)\") } sessio.close() } En ambd\u00f3s, tant en TercerAcces com en QuartAcces casos el resultat haur\u00e0 estat: La comarca Alcalat\u00e9n (prov\u00edncia de Castell\u00f3) t\u00e9 9 pobles Llista de pobles ----------------- Llucena (1417 habitants) Useres, les (992 habitants) Figueroles (549 habitants) Costur (562 habitants) Xodos (126 habitants) Alcora, l' (10672 habitants) Atzeneta del Maestrat (1321 habitants) Vistabella del Maestrat (384 habitants) Benafigos (156 habitants) Com veieu apareixen tots els pobles de la comarca que hem llegit, per\u00f2 com \u00e9s un conjunt (Set) no podem assegurar l'ordre. De fet, podria ser que a cadasc\u00fa de nosaltres li apareguen els pobles en ordre distint. Estaria b\u00e9 que aparegueren ordenats. Sempre ho podr\u00edem fer per mig d'una consulta i ordenar pel nom de la poblaci\u00f3 com veurem m\u00e9s avant. Per\u00f2 si ens interessa que els pobles apareguen sempre ordenats, podem fer una altra cosa: modificant el fitxer de mapatge, li podem dir que ens apareguen sempre ordenats per un camp. Ho hav\u00edem comentat en la pregunta 7, i ara anem a aplicar-lo. Per mig d'una senzilla indicaci\u00f3 en el fitxer de mapatge Comarca.hbm.xml , podem fer que les dades ens vinguen ordenades, \u00e9s a dir, que les poblacions d'una comarca ens vinguen per ordre alfab\u00e8tic. Senzillament ser\u00e0 posar order-by=\"nom\" en la definici\u00f3 del set poblacions . \u00c9s a dir haur\u00edem de substituir la l\u00ednia <set name=\"poblacions\" inverse=\"true\"> per <set name=\"poblacions\" inverse=\"true\" order-by=\"nom\"> I aix\u00ed li estem dient que les poblacions vinguen ordenades per nom, que \u00e9s el camp de la taula POBLACIO pel qual ens interessa ordenar. Nom\u00e9s fent aquesta modificaci\u00f3, el resultat tant del programa TercerAcces com el de QuartAccess ser\u00e0: La comarca Alcalat\u00e9n (prov\u00edncia de Castell\u00f3) t\u00e9 9 pobles Llista de pobles ----------------- Alcora, l' (10672 habitants) Atzeneta del Maestrat (1321 habitants) Benafigos (156 habitants) Costur (562 habitants) Figueroles (549 habitants) Llucena (1417 habitants) Useres, les (992 habitants) Vistabella del Maestrat (384 habitants) Xodos (126 habitants) 8.4 - Inserci\u00f3, modificaci\u00f3 i esborrat d'objectes En totes aquestes operacions d'actualitzaci\u00f3, recordem que far\u00e0 falta posar- les en una transacci\u00f3 per a que tinguen efecte. Inserci\u00f3 Nota A partir de la versi\u00f3 6.0 d'Hibernate, save() est\u00e0 deprecated, en favor de persist() Es fa amb els m\u00e8todes save() o persist() de la sessi\u00f3, passant-li l'objecte que volem guardar. Posem el mateix exemple de l'apartat 8.1, el d'inserir una comarca. Copieu l'exemple en un fitxer anomenat Exemple_11_Insercio.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction () val com = Comarca() com.nomC = \"Columbretes\" com.provincia = \"Castell\u00f3\" sessio.persist(com) t.commit() sessio.close() } Podem comprovar en la taula com apareix la comarca que acabem d'introduir: I evidentment ho podr\u00edem comprovar des de DBeaver Esborrat Nota A partir de la versi\u00f3 6.0 d'Hibernate, delete() est\u00e0 deprecated, en favor de remove() Amb els m\u00e8todes delete o remove , passant-li com a par\u00e0metre l'objecte. Pr\u00e8viament s'ha d'haver carregar l'objecte amb els m\u00e8todes load() o get() . Copieu el seg\u00fcent exemple en el fitxer Exemple_12_Esborrat.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = sessio.get(\"classes.Comarca\", \"Columbretes\") sessio.remove(com) t.commit() sessio.close() } Modificaci\u00f3 Nota A partir de la versi\u00f3 6.0 d'Hibernate, update est\u00e0 deprecated, en favor de merge() Amb el m\u00e8tode update() o merge() , passant-li com a par\u00e0metre l'objecte. Pr\u00e8viament haur\u00e0 d'haver estat carregat amb els m\u00e8todes load() o get() , igual que en el cas d'esborrar. En el seg\u00fcent exemple estem canviant la prov\u00edncia del Camp de Morvedre. Per a que no tinga efecte aquest canvi, i no modificar les dades que est\u00e0 utilitzant la resta de companys, observeu com al final estem fent un rollback . Copieu el seg\u00fcent en el fitxer Exemple_13_M odificacio.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = sessio.get(\"classes.Comarca\", \"Camp de Morvedre\") as Comarca com.provincia = \"Castell\u00f3\" sessio.merge(com) t.rollback() sessio.close() } En realitat tant el m\u00e8tode persist() com el m\u00e8tode merge() serveixen tant per a actualitzar un objecte ja existent (que ja era persistent) com per a crear-ne un nou si no existia. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"8 - Sessions i objectes hibernate"},{"location":"8__sessions_i_objectes_hibernate/#8-sessions-i-objectes-hibernate","text":"En aquesta secci\u00f3 comentarem el comportament de les sessions i dels objectes Hibernate (les classes creades per Hibernate). Recordem que el proc\u00e9s per a arribar a una sessi\u00f3 era Configuration - > SessionFactory -> Session . Les sent\u00e8ncies serien aquestes: val cfg = Configuration().configure() val sf = cfg.buildSessionFactory() val sessio = sf.openSession() La primera sent\u00e8ncia carrega el fitxer de configuraci\u00f3 hibernate.cfg.xml , i inicialitza l'entorn d'Hibernate. A partir d'aquest moment podem utilitzar l'objecte Configuration per crear el SessionFactory .","title":"8 - Sessions i objectes hibernate"},{"location":"8__sessions_i_objectes_hibernate/#81-transaccions","text":"El primer que haur\u00edem de fer notar \u00e9s que si el SGBD admet transaccions, les possibles modificacions que fem sobre una Base de Dades a trav\u00e9s d'Hibernate no es guardaran si no posem en marxa una transacci\u00f3. Per tant, si volem fer actualitzacions (insercions, esborrats i/o modificacions), el primer que haurem de fer en la sessi\u00f3 ser\u00e0 comen\u00e7ar una transacci\u00f3. Al final podrem confirmar amb commit o rebutjar totes les actualitzacions amb rollback . En el seg\u00fcent codi inserim una nova comarca. Utilitzem el m\u00e8tode save de la sessi\u00f3, per\u00f2 ja el veurem m\u00e9s avant. Ara nom\u00e9s volem il\u00b7lustrar una transacci\u00f3. No farem aquest exemple, ja que tots ens estem connectant com el mateix usuari a la mateixa Base de Dades, aleshores nom\u00e9s el primer ho podria fer, i a la reste ens donaria error perqu\u00e8 ja existiria la fila corresponent a aquesta nova comarca (restricci\u00f3 de clau principal) 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 val t = sessio.beginTransaction() 3 4 val com = Comarca() 5 com.nomC = \"Columbretes\" 6 com.provincia = \"Castell\u00f3\" 7 sessio.save(com) 8 9 t.commit() 10 sessio.close() En cas de no haver posat les dues sent\u00e8ncies de les l\u00ednies 2 i 9, no hauria hagut cap modificaci\u00f3. El m\u00e8tode beginTransaction() ha fet comen\u00e7ar la transacci\u00f3, i el m\u00e8tode commit() l'ha confirmada definitivament. Si en aquest moment vulgu\u00e9rem comen\u00e7ar una altra transacci\u00f3 seria suficient amb t.begin() . Per a no haver d'estar sempre pendents de transaccions, es podria posar en mode autocommit , \u00e9s a dir, que autom\u00e0ticament fa\u00e7a un commit despr\u00e9s de cada actualitzaci\u00f3 (despr\u00e9s de cada save() , delete() o update() ). Seria canviar en el fitxer hibernate.cfg.xml , posant la seg\u00fcent propietat entre les del < session-factory> : <property name=\"hibernate.connection.autocommit\">true</property> Tanmateix no \u00e9s tan fiable, i us recomane que utilitzeu transaccions, \u00e9s a dir, tenir el autocommit a false com estava per defecte i gestionar les transaccions manualment.","title":"8.1 - Transaccions"},{"location":"8__sessions_i_objectes_hibernate/#82-estats-dun-objecte-hibernate","text":"Els objectes de les classes que Hibernate ens ha ajudat a crear poden estar en m\u00e9s d'un estat, si mirem la seua sincronitzaci\u00f3 amb la Base de Dades: Transitori : quan l'objecte s'ha creat, per\u00f2 no s'ha associat a cap sessi\u00f3. \u00c9s a dir, ja s'ha creat amb la creaci\u00f3 de l'objecte i potser estiga buit o no (ja se li ha posat algun valor a alguna propietat), per\u00f2 encara no s'ha associat a cap sessi\u00f3. Es podr\u00e0 associar per exemple amb save() per a guardar l'objecte com hem vist en l'exemple de l'apartat anterior, o per exemple amb load() , com hav\u00edem vist en exemples anteriors per a agafar des de la Base de Dades. Persistent : quan l'objecte ja s'ha associat amb una sessi\u00f3 i per tant t\u00e9 una representaci\u00f3 en la Base de Dades i un valor identificador. Es pot haver guardat o carregat. Hibernate detectar\u00e0 qualsevol canvi fet sobre un objecte persistent i sincronitzar\u00e0 l'estat quan es complete la unitat de treball. I per a aix\u00f2 ja s'encarregar\u00e0 ell de fer els INSERT, DELETE o UPDATE en la Base de Dades. Nosaltres no ens haurem de preocupar. Separat : \u00e9s un objecte persistent, per\u00f2 que la seua sessi\u00f3 ha finalitzat. Es pot utilitzar, i fins i tot canviar l'estat, per\u00f2 no tindr\u00e0 efecte aquestos canvies la Base de Dades, a no ser que es torne a associar una altra vegada amb una sessi\u00f3, \u00e9s a dir, si es torna a fer persistent. De fet, \u00e9s una t\u00e8cnica de treball, utilitzar objectes separats quan l'usuari puga estar molt de temps sense interactuar, i quan torne a interactuar, tornar a fer-lo persistent. Anem a veure un exemple on es vegen els tres tipus d'estat. Tampoc cal que el feu vosaltres, est\u00e0 \u00fanicament a nivell il\u00b7lustratiu: val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = Comarca() // A partir d'ac\u00ed l'objecte \u00e9s transitori com.nomC = \"Columbretes\" com.provincia = \"Castell\u00f3\" sessio.save(com) // A partir d'ac\u00ed \u00e9s persistent t.commit() sessio.close() // A partir d'ac\u00ed \u00e9s separat, igual es pot utilitzar, // per\u00f2 no estar\u00e0 sincronitzat println(com.nomC + \" (\" + com.provincia + \")\")","title":"8.2 - Estats d'un objecte Hibernate"},{"location":"8__sessions_i_objectes_hibernate/#83-carrega-dobjectes-metodes-load-i-get","text":"La c\u00e0rrega d'objectes s'aconsegueix amb els m\u00e8todes load() i get() . S\u00f3n similars excepte en una q\u00fcesti\u00f3: el primer d\u00f3na un error si no es troba la fila, mentre que el segon contindr\u00e0 null. A m\u00e9s a partir d'Hibernate 6.0 load est\u00e0 deprecated , aix\u00ed que millor uilitzar get . Tant si utilitzem un com l'altre, haurem d'especificar 2 par\u00e0metres: la classe que volem buscar, i el valor de la clau principal de qui volem trobar. Aquest valor s'ha de passar amb el mateix tipus que la propietat corresponent a la clau principal , i en moltes ocasions haurem de canviar de tipus ( cast ). En el seg\u00fcent exemple, molt paregut al ja utilitzat anteriorment en SegonAcces , trobem la comarca Alt Maestrat (valor de nom_c , que correspon a la clau principal). En aquesta ocasi\u00f3 no cal canviar de tipus, ja que \u00e9s string: 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 3 val com = sessio.get(\"classes.Comarca\",\"Alt Maestrat\") as Comarca // c\u00e0rrega amb m\u00e8tode load() 4 5 println(\"Comarca \" + com.nomC + \": \" + com.provincia) 6 sessio.close() Com coment\u00e0vem, si no existira la comarca Alt Maestrat, donaria un error. Ac\u00ed tenim el mateix exemple, per\u00f2 utilitzant el m\u00e8tode get() i comprovant despr\u00e9s si com \u00e9s null, i aix\u00ed esquivem l'error: 1 val sessio = Configuration().configure().buildSessionFactory().openSession() 2 3 val com = sessio.get(\"classes.Comarca\",\"Al Maestrat\") as Comarca? // c\u00e0rrega amb m\u00e8tode get() 4 5 if (com==null) 6 println(\"No existeix la comarca\"); 7 else { 8 println(\"Comarca \" + com.nomC + \": \" + com.provincia) 9 } 10 sessio.close() Nom\u00e9s hem tingut la dificultat d'haver de posar Comarca? per si \u00e9s null el resultat de la consulta (justament el que volem comprovar) Anem a mirar la potencialitat que ens proporciona la manera que t\u00e9 Hibernate de construir les classes, amb el conjunt (o col\u00b7lecci\u00f3) de poblacions que t\u00e9 un objecte de la classe Comarca. Els Set es poden rec\u00f3rrer de m\u00e9s d'una manera. Una molt estesa \u00e9s utilitzar un iterator , utilitzant els m\u00e8todes hasNext() que ens diu si hi ha m\u00e9s elements en la col\u00b7lecci\u00f3, i next() que torna el seg\u00fcent element de la col\u00b7lecci\u00f3. En el seg\u00fcent programa anem a visualitzar informaci\u00f3 de la comarca de l' Alcalat\u00e9n , i tamb\u00e9 els seus pobles. Estan marcades les l\u00ednies de la utilitzaci\u00f3 del Iterator . Copieu-lo en un fitxer Kotlin anomenat Exemple_03_TercerAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alcalat\u00e9n\") as Comarca print(\"La comarca \" + com.nomC) print(\" (prov\u00edncia de \" + com.provincia + \") \") println(\"t\u00e9 \" + com.poblacions.size + \" pobles\") println() println(\"Llista de pobles\") println(\"-----------------\") val it = com.poblacions.iterator()!! while (it.hasNext()) { val p = it.next() System.out.println(p.nom + \" (\" + p.poblacio + \" habitants)\") } sessio.close() } Per\u00f2 m\u00e9s senzilla encara \u00e9s la utilitzaci\u00f3 del bucle foreach , que fa el recorregut ell sol, tenint disponible cada element. La sintaxi en Kotlin pot ser de dues maneres. Posem com queda l'exemple anterior de cadascuna de les dues maneres for ( e in conjunt ) i e anir\u00e0 agafant tots els valors de la col\u00b7lecci\u00f3. for (p in com.poblacions!!) { println(p.nom + \" (\" + p.poblacio + \" habitants)\") } conjunt. forEach() i dins dels par\u00e8ntesis utilitzem cada element com it com.poblacions!!.forEach { println(it.nom + \" (\" + it.poblacio + \" habitants)\") } Utilitzarem la primera forma, que \u00e9s la m\u00e9s c\u00f2moda, i quedar\u00e0 de la seg\u00fcent manera. Guardeu el seg\u00fcent programa en fitxer Kotlin anomenat Exemple_04_QuartAcces.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val com = sessio.get(\"classes.Comarca\", \"Alcalat\u00e9n\") as Comarca print(\"La comarca \" + com.nomC) print(\" (prov\u00edncia de \" + com.provincia + \") \") println(\"t\u00e9 \" + com.poblacions.size + \" pobles\") println() println(\"Llista de pobles\") println(\"-----------------\") for (p in com.poblacions) { println(p.nom + \" (\" + p.poblacio + \" habitants)\") } sessio.close() } En ambd\u00f3s, tant en TercerAcces com en QuartAcces casos el resultat haur\u00e0 estat: La comarca Alcalat\u00e9n (prov\u00edncia de Castell\u00f3) t\u00e9 9 pobles Llista de pobles ----------------- Llucena (1417 habitants) Useres, les (992 habitants) Figueroles (549 habitants) Costur (562 habitants) Xodos (126 habitants) Alcora, l' (10672 habitants) Atzeneta del Maestrat (1321 habitants) Vistabella del Maestrat (384 habitants) Benafigos (156 habitants) Com veieu apareixen tots els pobles de la comarca que hem llegit, per\u00f2 com \u00e9s un conjunt (Set) no podem assegurar l'ordre. De fet, podria ser que a cadasc\u00fa de nosaltres li apareguen els pobles en ordre distint. Estaria b\u00e9 que aparegueren ordenats. Sempre ho podr\u00edem fer per mig d'una consulta i ordenar pel nom de la poblaci\u00f3 com veurem m\u00e9s avant. Per\u00f2 si ens interessa que els pobles apareguen sempre ordenats, podem fer una altra cosa: modificant el fitxer de mapatge, li podem dir que ens apareguen sempre ordenats per un camp. Ho hav\u00edem comentat en la pregunta 7, i ara anem a aplicar-lo. Per mig d'una senzilla indicaci\u00f3 en el fitxer de mapatge Comarca.hbm.xml , podem fer que les dades ens vinguen ordenades, \u00e9s a dir, que les poblacions d'una comarca ens vinguen per ordre alfab\u00e8tic. Senzillament ser\u00e0 posar order-by=\"nom\" en la definici\u00f3 del set poblacions . \u00c9s a dir haur\u00edem de substituir la l\u00ednia <set name=\"poblacions\" inverse=\"true\"> per <set name=\"poblacions\" inverse=\"true\" order-by=\"nom\"> I aix\u00ed li estem dient que les poblacions vinguen ordenades per nom, que \u00e9s el camp de la taula POBLACIO pel qual ens interessa ordenar. Nom\u00e9s fent aquesta modificaci\u00f3, el resultat tant del programa TercerAcces com el de QuartAccess ser\u00e0: La comarca Alcalat\u00e9n (prov\u00edncia de Castell\u00f3) t\u00e9 9 pobles Llista de pobles ----------------- Alcora, l' (10672 habitants) Atzeneta del Maestrat (1321 habitants) Benafigos (156 habitants) Costur (562 habitants) Figueroles (549 habitants) Llucena (1417 habitants) Useres, les (992 habitants) Vistabella del Maestrat (384 habitants) Xodos (126 habitants)","title":"8.3 - C\u00e0rrega d'objectes: m\u00e8todes load() i get()"},{"location":"8__sessions_i_objectes_hibernate/#84-insercio-modificacio-i-esborrat-dobjectes","text":"En totes aquestes operacions d'actualitzaci\u00f3, recordem que far\u00e0 falta posar- les en una transacci\u00f3 per a que tinguen efecte. Inserci\u00f3 Nota A partir de la versi\u00f3 6.0 d'Hibernate, save() est\u00e0 deprecated, en favor de persist() Es fa amb els m\u00e8todes save() o persist() de la sessi\u00f3, passant-li l'objecte que volem guardar. Posem el mateix exemple de l'apartat 8.1, el d'inserir una comarca. Copieu l'exemple en un fitxer anomenat Exemple_11_Insercio.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction () val com = Comarca() com.nomC = \"Columbretes\" com.provincia = \"Castell\u00f3\" sessio.persist(com) t.commit() sessio.close() } Podem comprovar en la taula com apareix la comarca que acabem d'introduir: I evidentment ho podr\u00edem comprovar des de DBeaver Esborrat Nota A partir de la versi\u00f3 6.0 d'Hibernate, delete() est\u00e0 deprecated, en favor de remove() Amb els m\u00e8todes delete o remove , passant-li com a par\u00e0metre l'objecte. Pr\u00e8viament s'ha d'haver carregar l'objecte amb els m\u00e8todes load() o get() . Copieu el seg\u00fcent exemple en el fitxer Exemple_12_Esborrat.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = sessio.get(\"classes.Comarca\", \"Columbretes\") sessio.remove(com) t.commit() sessio.close() } Modificaci\u00f3 Nota A partir de la versi\u00f3 6.0 d'Hibernate, update est\u00e0 deprecated, en favor de merge() Amb el m\u00e8tode update() o merge() , passant-li com a par\u00e0metre l'objecte. Pr\u00e8viament haur\u00e0 d'haver estat carregat amb els m\u00e8todes load() o get() , igual que en el cas d'esborrar. En el seg\u00fcent exemple estem canviant la prov\u00edncia del Camp de Morvedre. Per a que no tinga efecte aquest canvi, i no modificar les dades que est\u00e0 utilitzant la resta de companys, observeu com al final estem fent un rollback . Copieu el seg\u00fcent en el fitxer Exemple_13_M odificacio.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val t = sessio.beginTransaction() val com = sessio.get(\"classes.Comarca\", \"Camp de Morvedre\") as Comarca com.provincia = \"Castell\u00f3\" sessio.merge(com) t.rollback() sessio.close() } En realitat tant el m\u00e8tode persist() com el m\u00e8tode merge() serveixen tant per a actualitzar un objecte ja existent (que ja era persistent) com per a crear-ne un nou si no existia. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"8.4 - Inserci\u00f3, modificaci\u00f3 i esborrat d'objectes"},{"location":"9__consultes/","text":"9 - Consultes Hem vist com podem accedir molt c\u00f2modament a les classes que equivalen a una taula. Per\u00f2 en moltes ocasions ens far\u00e0 falta accedir no exactament a una taula sin\u00f3 a una combinaci\u00f3 de taules, o en definitiva voldrem informaci\u00f3 m\u00e9s elaborada. Per a poder \"interrogar\" a la Base de Dades amb consultes m\u00e9s complexes, Hibernate suporta un llenguatge de consulta Orientat a Objectes anomenat HQL ( Hibernate Query Language ), molt paregut a SQL ja que \u00e9s una extensi\u00f3 Orientada a Objectes d'aquest. En aquest sentit s'ha intentat fer un est\u00e0ndar de llenguatge de consulta anomenat OQL ( Object Query Language ), desenvolupat per un grup amb \u00e0nim de crear un est\u00e0ndar ODMG (Object Data Management Group). Aquest est\u00e0ndar no l'ha implementat al 100% cap producte comercial, i en realitat tenim subconjunts d'aquest est\u00e0ndar. Utilitzarem la classe Query , i invocarem al m\u00e8tode createQuery() de Session , que justament torna una Query. Aquest seria un exemple. Observeu que com a primer par\u00e0metre se li passa la sent\u00e8ncia, i com a segon par\u00e0metre el tipus que torna; com que les classes no les hem tradu\u00efdes a Kotlin, hem d'especificar que s\u00f3n de Java: val q = sessio.createQuery(\"from Comarca\", Comarca::class.java) Nota Abans no calia el segon par\u00e0metre, per\u00f2 des de la versi\u00f3 d' Hibernate 6 , marca com a deprecated el createQuery si no es posa aquest segon par\u00e0metre Per a recuperar les dades tenim dues possibilitats, utilitzant dos m\u00e8todes de la query: M\u00e8tode list() : torna tots els resultats de la consulta en una col\u00b7lecci\u00f3 ( List) . Aquest m\u00e8tode fa una crida \u00fanica al SGBD i es duran totes les dades. Haur\u00e0 d'haver, per tant, mem\u00f2ria suficient per a que c\u00e0piguen tots els resultats. Si \u00e9s una quantitat gran de resultats, tardar\u00e0 molt en executar-se. M\u00e8tode iterate() : torna un iterador per a poder rec\u00f3rrer els resultats de la consulta. Hibernate executa la sent\u00e8ncia, per\u00f2 nom\u00e9s torna els identificadors de les files del resultat, i cada vegada que fem next() del iterador, s'executa realment la consulta tornant la seg\u00fcent fila. Per tant fa falta molta menys mem\u00f2ria. Per contra es fan mots m\u00e9s accessos a la Base de Dades, encara que cadascun tardar\u00e0 molt poc, per\u00f2 en total tardar\u00e0 m\u00e9s. Es pot fins i tot fixar la quantitat de files a tornar amb el m\u00e8tode setFetchSize() . En el seg\u00fcents dos exemples, que s\u00f3n equivalents, es trau una llista de totes les comarques. El primer utilitza el m\u00e8tode list() i el segon el m\u00e8tode iterate() . I en aquesta ocasi\u00f3 utilitzem un iterador per a rec\u00f3rrer la llista (List) en compte de foreach , per veure m\u00e9s d'una manera, i per similitud amb el segon exemple. Poseu a aquest primer exemple el nom de Exemple_21_AccesAmbList.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery (\"from Comarca\", Comarca::class.java) val llista = q.list () val it = llista.iterator () while (it.hasNext()) { val com = it.next() // no fa falta fer un casting perqu\u00e8 ja sap que \u00e9s Comarca println(com.nomC + \" - \" + com.provincia) } sessio.close() } Aquest ser\u00e0 el resultat: Safor - Val\u00e8ncia Horta Sud - Val\u00e8ncia Foia de Bunyol - Val\u00e8ncia Plana Baixa - Castell\u00f3 Horta Nord - Val\u00e8ncia Rac\u00f3 - Val\u00e8ncia Plana d'Utiel - Val\u00e8ncia Vall de Cofrents - Val\u00e8ncia Ribera Baixa - Val\u00e8ncia Ribera Alta - Val\u00e8ncia Marina Alta - Alacant Serrans - Val\u00e8ncia Val\u00e8ncia - Val\u00e8ncia Baix Maestrat - Castell\u00f3 Marina Baixa - Alacant Vall d'Albaida - Val\u00e8ncia Canal de Navarr\u00e9s - Val\u00e8ncia Horta Oest - Val\u00e8ncia Camp de T\u00faria - Val\u00e8ncia Alt Millars - Castell\u00f3 Baix Vinalop\u00f3 - Alacant Comtat - Alacant Alt Pal\u00e0ncia - Castell\u00f3 Plana Alta - Castell\u00f3 Alacant\u00ed - Alacant Camp de Morvedre - Val\u00e8ncia Alt Vinalop\u00f3 - Alacant Costera - Val\u00e8ncia Alcalat\u00e9n - Castell\u00f3 Alcoi\u00e0 - Alacant Vinalop\u00f3 Mitj\u00e0 - Alacant Alt Maestrat - Castell\u00f3 Baix Segura - Alacant Ports - Castell\u00f3 Encara que la manera m\u00e9s curta i potser m\u00e9s clara \u00e9s utilitzant un bucle foreach amb el m\u00e8tode list() . Nom\u00e9s haurem d'anar amb compte de fer un cast per a que s\u00e0piga quin tipus d'element \u00e9s. Copieu aquest tercer exemple al fitxer Exemple_22_AccesAmbListForEach.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery (\"from Comarca\", Comarca::class.java) for (c in q.list()) { println(c.nomC + \" --- \" + c.provincia) } sessio.close() } Si sabem que la consulta tornar\u00e0 \u00fanicament una fila, podem assignar aquesta fila a un objecte de la classe de la taula afectada, posant el m\u00e8tode uniqueResult() en la creaci\u00f3 de la query, aix\u00ed ens estalviem passos. Copieu el seg\u00fcent programa al fitxer kotlin Exemple_23_AccesAmbUniqueResult.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val d = sessio.createQuery (\"from Comarca where nomC='Alcalat\u00e9n'\",Comarca::class.java).uniqueResult() println(d.nomC + \" - \" + d.provincia) sessio.close() } Per\u00f2 en realitat en aquest exemple poca cosa hem guanyat, perqu\u00e8 per a agafar l'objecte corresponent a una \u00fanica fila d'una taula, ja ho f\u00e9iem amb session.get() . M\u00e9s endavant veurem consultes m\u00e9s complicades on trobarem la utilitat. 9.1 - Par\u00e0metres en les consultes createQuery() admet tamb\u00e9 la utilitzaci\u00f3 de par\u00e0metres, igual que feia les sent\u00e8ncies PreparedStatement del tema anterior. La manera de posar-les \u00e9s prou similar al vist en aquella ocasi\u00f3. Ara, per\u00f2, ho ampliarem un poc. La manera de posar valor als par\u00e0metres ser\u00e0 utilitzant el m\u00e8todes setParameter() que tindr\u00e0 2 par\u00e0metres, el primer per a assenyalar el par\u00e0metre, i el segon per a indicar el valor. De moment tot igual que en el PreparedStatement . Per\u00f2 ara veurem 2 maneres de posar par\u00e0metres en la consulta: Amb ?i , utilitzant el m\u00e8tode setParameter(int, valor ) i indicant el n\u00famero el mateix que despr\u00e9s de la interrogant (la i) . Amb : nom , utilitzant el m\u00e8tode setParameter(string, valor ) i indicant el nom del par\u00e0metre Ho veurem molt m\u00e9s clar en un exemple, millor dit, en dues versions del mateix exemple. Intentarem traure les poblacions d'una determinada comarca, que tenen una altura determinada o major. I aquestos dos valors els posarem com a par\u00e0metres, i aix\u00ed podrem practicar les dues formes. Els valors que posarem per a la comarca ser\u00e0 Alcalat\u00e9n , i l'altura 500 En aquesta primera versi\u00f3 assenyalem els par\u00e0metres amb ?i a l'estil de JDBC . Copieu el seg\u00fcent codi al fitxer Exemple_31_ConsultesAmbParametres1.kt package exemples import classes.Poblacio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio where altura>=?1 and comarca.nomC=?2\", Poblacio::class.java) q.setParameter(1, 500) q.setParameter(2, \"Alcalat\u00e9n\") for (p in q.list()) { p as Poblacio println(p.nom + \" - \" + p.altura) } sessio.close() } Nota En versions anteriors a banda de setParameter() s'utilitzaven els m\u00e8todes setInteger() , setString() ... per\u00f2 des de la versi\u00f3 6 d'Hibernate ja no existeixen En la segona posem els par\u00e0metres de l'altra manera. Copieu el seg\u00fcent codi al fitxer Exemple_32_ConsultesAmbParametres2.kt package exemples import classes.Poblacio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio where altura>=:alt and comarca.nomC=:com\", Poblacio::class.java) q.setParameter(\"alt\",500) q.setParameter(\"com\",\"Alcalat\u00e9n\") for (p in q.list()) { p as Poblacio println(p.nom + \" - \" + p.altura) } sessio.close() } 9.2 - Consultes diferents a una classe ja definida De moment en les consultes sempre hem tornat una fila o m\u00e9s per\u00f2 sempre d'una \u00fanica taula , o millor dit, una classe equivalent a una taula. Per\u00f2 hi haur\u00e0 moltes ocasions en qu\u00e8 voldrem fer una consulta diferent, on intervinga m\u00e9s d'una taula (o classe), que torne funcions de grup (SUM, AVG, ...), en definitiva que no siga una sent\u00e8ncia equivalent a SELECT * FROM ... Per tant ara no tornar\u00e0 un objecte o una col\u00b7lecci\u00f3 d'objectes dels que ja tenim definits. Podem tenir m\u00e9s d'un cas, i a continuaci\u00f3 els intentarem tractar: Consultes que tornen m\u00e9s d'un objecte dels definits S\u00f3n consultes en les quals hi haur\u00e0 una reuni\u00f3 de taules (millor dit, de les classes equivalents), i es tornen tots els camps (totes les propietats). Podr\u00edem definir-nos una classe que englobara totes les propietats de tots els objectes, per\u00f2 hi ha una soluci\u00f3 m\u00e9s r\u00e0pida. Els resultats s'obtenen en un array d'objectes , on el primer objecte ser\u00e0 l'equivalent de la primera taula, el segon l'equivalent de la segona, etc. Per tant, la classe que posem com a segon par\u00e0metre del createQuery sera Array::class.java . Aquest exemple, on traurem el nom de la comarca i la prov\u00edncia, \u00e9s nom\u00e9s il\u00b7lustratiu. Est\u00e0 clar que es pot fer molt m\u00e9s curt i senzill agafant \u00fanicament les Poblacions i a partir d'elles traure la comarca. Copieu el seg\u00fcent codi al fitxer Exemple_41_ConsultaComplexa1.kt : package exemples import classes.Poblacio import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio p, Comarca c where p.comarca.nomC=c.nomC order by p.nom\", Array::class.java) for(tot in q.list()) { val p = tot[0] as Poblacio val c = tot[1] as Comarca println(p.nom + \" (\" + c.nomC + \". \" + c.provincia + \")\") } sessio.close() } Com veiem, un poc \"rotllo\"... Consultes que tornen un \u00fanic valor Aquest \u00e9s el cas m\u00e9s senzill, ja que el valor tornat el podem agafar del tipus b\u00e0sic del valor tornat. Normalment \u00e9s despr\u00e9s d'utilitzar una funci\u00f3 de grup. Recordem que ha de tornar un \u00fanic valor (una \u00fanica fila i una \u00fanica columna, per dir-lo aix\u00ed). La classe que posem com a segon par\u00e0metre del createQuery har\u00e0 de ser la del valor tornat. En aquest cas que calculem la mitjana, a classe oportuna ser\u00e0 Double . Si compt\u00e0rem, per exemple, seria Long . Haurem d'utilitzar el m\u00e8tode uniqueResult() ja comentat amb anterioritat. L'exemple ser\u00e0 per a calcular l'altura mitjana de totes les poblacions. Copieu el seg\u00fcent codi al fitxer Kotlin Exemple_42_ConsultaComplexa2.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"select avg(altura) from Poblacio\",Double::class.java) val mitjana = q.uniqueResult () println(\"Altura mitjana: \" + mitjana) sessio.close() } Consultes amb qualsevol resultat Una de les solucions seria crear una classe amb totes les propietats que torna la consulta. No veurem aquesta soluci\u00f3 per tediosa. Farem com en el primer apartat d'aquesta pregunta, gestionant l' array d'objectes que s'obtenen, per\u00f2 en aquesta ocasi\u00f3 cada objecte de l'array ser\u00e0 un tipus simple. Copieu el seg\u00fcent codi al fitxer Exemple_43_ConsultaComplexa3.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"select c.nomC,count(p.codM),avg(p.altura) \" + \"from Comarca c , Poblacio p \" + \"where c.nomC=p.comarca.nomC \" + \"group by c.nomC \" + \"order by c.nomC\", Array::class.java); for (tot in q.list()){ println(\"Comarca: \" + tot[0] + \". N\u00fam. pobles: \" + tot[1] + \". Altura mitjana: \" + tot[2]); } sessio.close() } Nom\u00e9s hem d'anar amb compte amb posar com a segon par\u00e0metre de createQuery el tipus Array::class.java . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"9 - Consultes"},{"location":"9__consultes/#9-consultes","text":"Hem vist com podem accedir molt c\u00f2modament a les classes que equivalen a una taula. Per\u00f2 en moltes ocasions ens far\u00e0 falta accedir no exactament a una taula sin\u00f3 a una combinaci\u00f3 de taules, o en definitiva voldrem informaci\u00f3 m\u00e9s elaborada. Per a poder \"interrogar\" a la Base de Dades amb consultes m\u00e9s complexes, Hibernate suporta un llenguatge de consulta Orientat a Objectes anomenat HQL ( Hibernate Query Language ), molt paregut a SQL ja que \u00e9s una extensi\u00f3 Orientada a Objectes d'aquest. En aquest sentit s'ha intentat fer un est\u00e0ndar de llenguatge de consulta anomenat OQL ( Object Query Language ), desenvolupat per un grup amb \u00e0nim de crear un est\u00e0ndar ODMG (Object Data Management Group). Aquest est\u00e0ndar no l'ha implementat al 100% cap producte comercial, i en realitat tenim subconjunts d'aquest est\u00e0ndar. Utilitzarem la classe Query , i invocarem al m\u00e8tode createQuery() de Session , que justament torna una Query. Aquest seria un exemple. Observeu que com a primer par\u00e0metre se li passa la sent\u00e8ncia, i com a segon par\u00e0metre el tipus que torna; com que les classes no les hem tradu\u00efdes a Kotlin, hem d'especificar que s\u00f3n de Java: val q = sessio.createQuery(\"from Comarca\", Comarca::class.java) Nota Abans no calia el segon par\u00e0metre, per\u00f2 des de la versi\u00f3 d' Hibernate 6 , marca com a deprecated el createQuery si no es posa aquest segon par\u00e0metre Per a recuperar les dades tenim dues possibilitats, utilitzant dos m\u00e8todes de la query: M\u00e8tode list() : torna tots els resultats de la consulta en una col\u00b7lecci\u00f3 ( List) . Aquest m\u00e8tode fa una crida \u00fanica al SGBD i es duran totes les dades. Haur\u00e0 d'haver, per tant, mem\u00f2ria suficient per a que c\u00e0piguen tots els resultats. Si \u00e9s una quantitat gran de resultats, tardar\u00e0 molt en executar-se. M\u00e8tode iterate() : torna un iterador per a poder rec\u00f3rrer els resultats de la consulta. Hibernate executa la sent\u00e8ncia, per\u00f2 nom\u00e9s torna els identificadors de les files del resultat, i cada vegada que fem next() del iterador, s'executa realment la consulta tornant la seg\u00fcent fila. Per tant fa falta molta menys mem\u00f2ria. Per contra es fan mots m\u00e9s accessos a la Base de Dades, encara que cadascun tardar\u00e0 molt poc, per\u00f2 en total tardar\u00e0 m\u00e9s. Es pot fins i tot fixar la quantitat de files a tornar amb el m\u00e8tode setFetchSize() . En el seg\u00fcents dos exemples, que s\u00f3n equivalents, es trau una llista de totes les comarques. El primer utilitza el m\u00e8tode list() i el segon el m\u00e8tode iterate() . I en aquesta ocasi\u00f3 utilitzem un iterador per a rec\u00f3rrer la llista (List) en compte de foreach , per veure m\u00e9s d'una manera, i per similitud amb el segon exemple. Poseu a aquest primer exemple el nom de Exemple_21_AccesAmbList.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery (\"from Comarca\", Comarca::class.java) val llista = q.list () val it = llista.iterator () while (it.hasNext()) { val com = it.next() // no fa falta fer un casting perqu\u00e8 ja sap que \u00e9s Comarca println(com.nomC + \" - \" + com.provincia) } sessio.close() } Aquest ser\u00e0 el resultat: Safor - Val\u00e8ncia Horta Sud - Val\u00e8ncia Foia de Bunyol - Val\u00e8ncia Plana Baixa - Castell\u00f3 Horta Nord - Val\u00e8ncia Rac\u00f3 - Val\u00e8ncia Plana d'Utiel - Val\u00e8ncia Vall de Cofrents - Val\u00e8ncia Ribera Baixa - Val\u00e8ncia Ribera Alta - Val\u00e8ncia Marina Alta - Alacant Serrans - Val\u00e8ncia Val\u00e8ncia - Val\u00e8ncia Baix Maestrat - Castell\u00f3 Marina Baixa - Alacant Vall d'Albaida - Val\u00e8ncia Canal de Navarr\u00e9s - Val\u00e8ncia Horta Oest - Val\u00e8ncia Camp de T\u00faria - Val\u00e8ncia Alt Millars - Castell\u00f3 Baix Vinalop\u00f3 - Alacant Comtat - Alacant Alt Pal\u00e0ncia - Castell\u00f3 Plana Alta - Castell\u00f3 Alacant\u00ed - Alacant Camp de Morvedre - Val\u00e8ncia Alt Vinalop\u00f3 - Alacant Costera - Val\u00e8ncia Alcalat\u00e9n - Castell\u00f3 Alcoi\u00e0 - Alacant Vinalop\u00f3 Mitj\u00e0 - Alacant Alt Maestrat - Castell\u00f3 Baix Segura - Alacant Ports - Castell\u00f3 Encara que la manera m\u00e9s curta i potser m\u00e9s clara \u00e9s utilitzant un bucle foreach amb el m\u00e8tode list() . Nom\u00e9s haurem d'anar amb compte de fer un cast per a que s\u00e0piga quin tipus d'element \u00e9s. Copieu aquest tercer exemple al fitxer Exemple_22_AccesAmbListForEach.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery (\"from Comarca\", Comarca::class.java) for (c in q.list()) { println(c.nomC + \" --- \" + c.provincia) } sessio.close() } Si sabem que la consulta tornar\u00e0 \u00fanicament una fila, podem assignar aquesta fila a un objecte de la classe de la taula afectada, posant el m\u00e8tode uniqueResult() en la creaci\u00f3 de la query, aix\u00ed ens estalviem passos. Copieu el seg\u00fcent programa al fitxer kotlin Exemple_23_AccesAmbUniqueResult.kt : package exemples import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val d = sessio.createQuery (\"from Comarca where nomC='Alcalat\u00e9n'\",Comarca::class.java).uniqueResult() println(d.nomC + \" - \" + d.provincia) sessio.close() } Per\u00f2 en realitat en aquest exemple poca cosa hem guanyat, perqu\u00e8 per a agafar l'objecte corresponent a una \u00fanica fila d'una taula, ja ho f\u00e9iem amb session.get() . M\u00e9s endavant veurem consultes m\u00e9s complicades on trobarem la utilitat.","title":"9 - Consultes"},{"location":"9__consultes/#91-parametres-en-les-consultes","text":"createQuery() admet tamb\u00e9 la utilitzaci\u00f3 de par\u00e0metres, igual que feia les sent\u00e8ncies PreparedStatement del tema anterior. La manera de posar-les \u00e9s prou similar al vist en aquella ocasi\u00f3. Ara, per\u00f2, ho ampliarem un poc. La manera de posar valor als par\u00e0metres ser\u00e0 utilitzant el m\u00e8todes setParameter() que tindr\u00e0 2 par\u00e0metres, el primer per a assenyalar el par\u00e0metre, i el segon per a indicar el valor. De moment tot igual que en el PreparedStatement . Per\u00f2 ara veurem 2 maneres de posar par\u00e0metres en la consulta: Amb ?i , utilitzant el m\u00e8tode setParameter(int, valor ) i indicant el n\u00famero el mateix que despr\u00e9s de la interrogant (la i) . Amb : nom , utilitzant el m\u00e8tode setParameter(string, valor ) i indicant el nom del par\u00e0metre Ho veurem molt m\u00e9s clar en un exemple, millor dit, en dues versions del mateix exemple. Intentarem traure les poblacions d'una determinada comarca, que tenen una altura determinada o major. I aquestos dos valors els posarem com a par\u00e0metres, i aix\u00ed podrem practicar les dues formes. Els valors que posarem per a la comarca ser\u00e0 Alcalat\u00e9n , i l'altura 500 En aquesta primera versi\u00f3 assenyalem els par\u00e0metres amb ?i a l'estil de JDBC . Copieu el seg\u00fcent codi al fitxer Exemple_31_ConsultesAmbParametres1.kt package exemples import classes.Poblacio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio where altura>=?1 and comarca.nomC=?2\", Poblacio::class.java) q.setParameter(1, 500) q.setParameter(2, \"Alcalat\u00e9n\") for (p in q.list()) { p as Poblacio println(p.nom + \" - \" + p.altura) } sessio.close() } Nota En versions anteriors a banda de setParameter() s'utilitzaven els m\u00e8todes setInteger() , setString() ... per\u00f2 des de la versi\u00f3 6 d'Hibernate ja no existeixen En la segona posem els par\u00e0metres de l'altra manera. Copieu el seg\u00fcent codi al fitxer Exemple_32_ConsultesAmbParametres2.kt package exemples import classes.Poblacio import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio where altura>=:alt and comarca.nomC=:com\", Poblacio::class.java) q.setParameter(\"alt\",500) q.setParameter(\"com\",\"Alcalat\u00e9n\") for (p in q.list()) { p as Poblacio println(p.nom + \" - \" + p.altura) } sessio.close() }","title":"9.1 - Par\u00e0metres en les consultes"},{"location":"9__consultes/#92-consultes-diferents-a-una-classe-ja-definida","text":"De moment en les consultes sempre hem tornat una fila o m\u00e9s per\u00f2 sempre d'una \u00fanica taula , o millor dit, una classe equivalent a una taula. Per\u00f2 hi haur\u00e0 moltes ocasions en qu\u00e8 voldrem fer una consulta diferent, on intervinga m\u00e9s d'una taula (o classe), que torne funcions de grup (SUM, AVG, ...), en definitiva que no siga una sent\u00e8ncia equivalent a SELECT * FROM ... Per tant ara no tornar\u00e0 un objecte o una col\u00b7lecci\u00f3 d'objectes dels que ja tenim definits. Podem tenir m\u00e9s d'un cas, i a continuaci\u00f3 els intentarem tractar: Consultes que tornen m\u00e9s d'un objecte dels definits S\u00f3n consultes en les quals hi haur\u00e0 una reuni\u00f3 de taules (millor dit, de les classes equivalents), i es tornen tots els camps (totes les propietats). Podr\u00edem definir-nos una classe que englobara totes les propietats de tots els objectes, per\u00f2 hi ha una soluci\u00f3 m\u00e9s r\u00e0pida. Els resultats s'obtenen en un array d'objectes , on el primer objecte ser\u00e0 l'equivalent de la primera taula, el segon l'equivalent de la segona, etc. Per tant, la classe que posem com a segon par\u00e0metre del createQuery sera Array::class.java . Aquest exemple, on traurem el nom de la comarca i la prov\u00edncia, \u00e9s nom\u00e9s il\u00b7lustratiu. Est\u00e0 clar que es pot fer molt m\u00e9s curt i senzill agafant \u00fanicament les Poblacions i a partir d'elles traure la comarca. Copieu el seg\u00fcent codi al fitxer Exemple_41_ConsultaComplexa1.kt : package exemples import classes.Poblacio import classes.Comarca import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"from Poblacio p, Comarca c where p.comarca.nomC=c.nomC order by p.nom\", Array::class.java) for(tot in q.list()) { val p = tot[0] as Poblacio val c = tot[1] as Comarca println(p.nom + \" (\" + c.nomC + \". \" + c.provincia + \")\") } sessio.close() } Com veiem, un poc \"rotllo\"... Consultes que tornen un \u00fanic valor Aquest \u00e9s el cas m\u00e9s senzill, ja que el valor tornat el podem agafar del tipus b\u00e0sic del valor tornat. Normalment \u00e9s despr\u00e9s d'utilitzar una funci\u00f3 de grup. Recordem que ha de tornar un \u00fanic valor (una \u00fanica fila i una \u00fanica columna, per dir-lo aix\u00ed). La classe que posem com a segon par\u00e0metre del createQuery har\u00e0 de ser la del valor tornat. En aquest cas que calculem la mitjana, a classe oportuna ser\u00e0 Double . Si compt\u00e0rem, per exemple, seria Long . Haurem d'utilitzar el m\u00e8tode uniqueResult() ja comentat amb anterioritat. L'exemple ser\u00e0 per a calcular l'altura mitjana de totes les poblacions. Copieu el seg\u00fcent codi al fitxer Kotlin Exemple_42_ConsultaComplexa2.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"select avg(altura) from Poblacio\",Double::class.java) val mitjana = q.uniqueResult () println(\"Altura mitjana: \" + mitjana) sessio.close() } Consultes amb qualsevol resultat Una de les solucions seria crear una classe amb totes les propietats que torna la consulta. No veurem aquesta soluci\u00f3 per tediosa. Farem com en el primer apartat d'aquesta pregunta, gestionant l' array d'objectes que s'obtenen, per\u00f2 en aquesta ocasi\u00f3 cada objecte de l'array ser\u00e0 un tipus simple. Copieu el seg\u00fcent codi al fitxer Exemple_43_ConsultaComplexa3.kt : package exemples import org.hibernate.cfg.Configuration import java.util.logging.Level import java.util.logging.LogManager fun main(args: Array<String>) { LogManager.getLogManager().getLogger(\"\").setLevel(Level.SEVERE) val sessio = Configuration().configure().buildSessionFactory().openSession() val q = sessio.createQuery(\"select c.nomC,count(p.codM),avg(p.altura) \" + \"from Comarca c , Poblacio p \" + \"where c.nomC=p.comarca.nomC \" + \"group by c.nomC \" + \"order by c.nomC\", Array::class.java); for (tot in q.list()){ println(\"Comarca: \" + tot[0] + \". N\u00fam. pobles: \" + tot[1] + \". Altura mitjana: \" + tot[2]); } sessio.close() } Nom\u00e9s hem d'anar amb compte amb posar com a segon par\u00e0metre de createQuery el tipus Array::class.java . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"9.2 - Consultes diferents a una classe ja definida"},{"location":"exercicis/","text":"Exercicis Exercici 5.1 Crea un projecte nou de l'estil de Java Enterprise anomenat Tema5_ PostgreSQL_Rutes_Anotacions . Inclou el driver JDBC de PostgreSQL. Has de fer el mapatge utilitzant anotacions (no els fitxer hbm.xml ) Fes el mapatge de les taules RUTA i PUNT , situades en la Base de Dades rutes a la qual pot accedir l'usuari rutes (contrasenya rutes ) i situada en el servidor de l'Institut ( 89.36.214.106 ). Guarda-les en un paquet anomenat classes . Veur\u00e0s que en el resultat apareixer\u00e0 tamb\u00e9 la classe PuntPK.java . \u00c9s a causa de que la clau principal de la taula PUNTS est\u00e0 formada per dos camps. \u00c9s la manera que t\u00e9 Hibernate de reflectir-ho. Tria tots els camps (que es convertiran en propietats). Canvia el nom d'alguna de les propietats Veur\u00e0s que en el resultat a m\u00e9s de les classes Ruta.java i Punt.java apareixer\u00e0 tamb\u00e9 la classe PuntPK.java . \u00c9s a causa de que la clau principal de la taula PUNTS est\u00e0 formada per dos camps. \u00c9s la manera que t\u00e9 Hibernate de reflectir-ho. Crea't el fitxer Kotlin VeureRutes.kt , que ser\u00e0 un programa senzill que visualitze les rutes, i el n\u00famero de punts, ordenades per nom de ruta, a m\u00e9s dels noms dels punts. Ha de ser per mig d'una consulta HQL (el m\u00e9s senzilla possible), i evidentment el programa ha de ser independent del n\u00famero de rutes existent en aquest moment a la Base de Dades. Intenta que no apareguen tots els warnings que apareixen per defecte. El m\u00e9s normal \u00e9s que t'aparega el seg\u00fcent error Repeated column in mapping for entity: classes.Punt column: num_r (should be mapped with insert=\"false\" update=\"false\") Per a corregir-ho has d'afegir a la classe Punt.java al final de tot, on apareix l'anotaci\u00f3 @JoinColumn , el que est\u00e0 en negreta a continuaci\u00f3. @ManyToOne @JoinColumn(name = \"num_r\", referencedColumnName = \"num_r\", nullable = false, insertable = false, updatable = false ) Una vegada corregit l'error, el resultat seria aquest: La Magdalena - 7 punts Primer Mol\u00ed Segon Mol\u00ed Camin\u00e0s Riu Sec Sant Roc Explanada La Magdalena Pelegrins de Les Useres - 6 punts Les Useres Les Torrocelles Lloma Bernat Xodos (Mol\u00ed) El Marinet Sant Joan Pujada a Penyagolosa - 5 punts Sant Joan Encreuament Barranc de la Pegunta El Corralico Penyagolosa Exercici 5.2 Sobre el projecte de Tema5_Hibernate_PostgreSQL_geo_ad , on tenim el mapatge de les taules COMARCA , POBLACIO i INSTITUT , creeu-vos un paquet anomenat exercicis , on col\u00b7locareu les classes d'aquest exercici. Per a visualitzar les coses d'una forma un poc m\u00e9s agradable anem a utilitzar les llibreries gr\u00e0fiques Java AWT i Javax Swing . Amb aquestes llibreries incorporarem: JPanel i JScrollPane , per a contenir altres objectes (aquest \u00faltim amb botons de scroll si s\u00f3n necessaris). JLabel , per a etiquetes JText , per a quadres de text (on poder posar informaci\u00f3) JTextArea , \u00e9s un quadre de text, per\u00f2 m\u00e9s gran. Nosaltres l'utilitzarem per a visualitzar informaci\u00f3 extensa, i per tant el farem no editable. JButton , per a botons. Estar\u00e0 esperant a que l'apretem (ActionListener) Tot a\u00e7\u00f2 anir\u00e0 en un fitxer que anomenarem Ex5_2_VeurePoblesComarca.kt I vosaltres haureu de completar el m\u00e8tode VisualitzaCom(comarca: String) , per a que si no existeix la comarca, es diga que no existeix dins del JTextArea, i si existeix, que es vegen els seus pobles (si vols pots millorar-lo per a que es vegen en ordre alfab\u00e8tic). package exercicis import java.awt.EventQueue import java.awt.BorderLayout import java.awt.FlowLayout import javax.swing.JFrame import javax.swing.JPanel import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel import javax.swing.JTextField import java.awt.Color import javax.swing.JScrollPane class Finestra : JFrame() { val etiqueta = JLabel(\"Comarca:\") val etIni = JLabel(\"Introdueix la comarca:\") val com = JTextField(15) val consultar = JButton(\"Consultar\") val area = JTextArea() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"HIBERNATE: Visualitzar Comarques i Pobles\") setBounds(100, 100, 450, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout ()) panell1.add(etIni) panell1.add(com) panell1.add(consultar) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout ()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) consultar.addActionListener() { etiqueta.setText(\"Comarca: \" + com.getText()) visualitzaCom(com.getText()) } } fun visualitzaCom(comarca: String){ // Instruccions per a llegir la comarca que arriba com a par\u00e0metre (s'ha de deixar en un objecte Comarca). // S'ha de cuidar que si no exiteix la comarca, en el JTextArea es pose que no existeix. // La manera d'anar introduint informaci\u00f3 en el JTextArea \u00e9s area.append(\"Linia que es vol introduir \") } } fun main() { EventQueue.invokeLater { Finestra().isVisible = true } } Aquest seria un exemple d'utilitzaci\u00f3: Exercici 5.3 Anem a fer unes quantes millores a l'exemple anterior. Les millores seran les seg\u00fcents: (70%) Substitueix el quadre de text per un JComboBox , i elimina el bot\u00f3. Recorda que el component JCombBox funciona de la seg\u00fcnet manera: Per a obtenir l'element seleccionat utilitzarem el m\u00e8tode .getSelectedItem() Per a omplir el ComboBox haurem de fer una consulta pr\u00e8via amb els noms de les comarques (en principi amb els noms \u00e9s suficient). Podrem anar afegint elements al ComboBox amb el m\u00e8tode .addItem() (15%) Substitueix el JTextArea on mostrem els pobles de la comarca per un JList . Aquest component ser\u00e0 una llista, i podrem seleccionar cada element de la llista. El seu funcionament \u00e9s aix\u00ed: Per a anar omplint el JList , no \u00e9s tant senzill com el JComboBox . Ens fa falta un DefaultListModel , i construir el JList a partir d'ell. Posteriorment afegirem elements al DefaultListModel , i aix\u00f2 suposar\u00e0 que es veuran en el JList . Ja tenim creat aquest DefaultListModel, i es diu listModel Per a agafar els pobles de la comarca podem fer-ho de 2 maneres: carregant un objecte Comarca, i a partir d'ell obtenir els pobles fent una consulta per agafar els pobles de la comrca. En aquest cas podem tenir el problema que hi haja cometes simples en el nom de la comarca (p.e. Vall d'Albaida). A\u00e7\u00f2 faria que la consulta HQL falle (ja que la cometa simple \u00e9s el delimitador de les constants de text). Una manera de solucionar-lo \u00e9s utilitzar un par\u00e0metre, ja que d'aquesta manera no hi haur\u00e0 problema amb les cometes. Una altra manera de solucionar-lo \u00e9s posar dos cometes simples. Podem utilitzar el m\u00e8tode replace() de la classe String, substituint tota cometa simple per dues cometes simples. Si per exemple tenim el nom de la comarca en el String comarca , far\u00edem: comarca.replace(\"'\",\"''\") (15%) Quan se seleccione un element del JList , fes que es mostre baix de tot el n\u00famero d'Instituts del poble seleccionat Per a poder controlar si s'ha seleccionat un element del JList escoltarem ambb area.addListSelectionListener() (si el JList s'anomena area , clar). \u00c9s on posarem les accions per a mostrar el nombre d'Instituts del poble ( visualitzaInstituts(String) ) El nom del poble tamb\u00e9 pot dur cometes simples, per tant farem la mateixa consideraci\u00f3 d'abans. Ho solucionem amb un par\u00e0metre, o posant dues cometes simple substituint el nom del poble per: poble.replace(\"'\",\"''\") L'esquelet quedar\u00e0 ara d'aquesta manera. Guardeu-lo en un fitxer anomenat Ex5_3_VeurePoblesComarca_Combobox.kt : import java.awt.EventQueue import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.Color import javax.swing.JFrame import javax.swing.JPanel import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JScrollPane import javax.swing.JComboBox import javax.swing.DefaultListModel import javax.swing.JList import classes.Comarca import classes.Poblacio class FinestraComboBox : JFrame() { val etiqueta = JLabel(\"Comarca:\") val etIni = JLabel(\"Introdueix la comarca:\") val com = JComboBox<String>() val listModel = DefaultListModel<String>() val area = JList(listModel) val peu = JTextField() val sessio = Configuration().configure().buildSessionFactory().openSession() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"HIBERNATE: Visualitzar Comarques i Pobles amb ComboBox\") setBounds(100, 100, 550, 400) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(etIni) panell1.add(com) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) getContentPane().add(peu, BorderLayout.SOUTH) agafarComarques() com.addActionListener() { visualitzaCom(com.getSelectedItem().toString()) } area.addListSelectionListener() { if (!area.isSelectionEmpty()) visualitzaInstituts(area.getSelectedValue()) else peu.setText(\"\") } } fun agafarComarques() { // Instruccions per a posar en el ComboBox el nom de totes les comarques, millor si \u00e9s per ordre alfab\u00e8tic } fun visualitzaCom(comarca: String) { // Instruccions per a llegir la comarca que arriba com a par\u00e0metre (s'ha de deixar en un objecte Comarca). // S'ha de cuidar que si no exiteix la comarca, en el JList es pose que no existeix. // La manera d'anar introduint informaci\u00f3 en el JList \u00e9s a trav\u00e9s del DefaultListModel: // listModel.addElement(\"Linia que es vol introduir \") // Per a esborrar els element del JList: listModel.clear() // Es pot fer carregant un objecte, o per mig de consulta, per\u00f2 en aquest cas podem tenir problemes amb ' // Una manera de solucionar el problema de la cometa simple \u00e9s utilitzar comarca.replaceAll(\"'\",\"''\"). // Una altra \u00e9s utilitzar par\u00e0metres } fun visualitzaInstituts(poble: String) { // Instruccions per a mostrar el n\u00famero d'Instituts del poble seleccionat // La millor manera \u00e9s per mig d'una consulta. Podem tenir problemes amb la cometa simple // Una manera de solucionar el problema de la cometa simple \u00e9s utilitzar poble.replaceAll(\"'\",\"''\"). // Una altra \u00e9s utilitzar par\u00e0metres } } fun main() { EventQueue.invokeLater { FinestraComboBox().isVisible = true } } Aquest seria un exemple d'execuci\u00f3: Exercici 5.4 Anem a intentar un programa per al manteniment de les comarques (no intentarem mantenir els pobles de la comarca, \u00fanicament el nom i la prov\u00edncia de la comarca). Ha d'estar en el paquet Exercicis del projecte Tema5_Hibernate_PostgreSQL_geo_ad. En una primera fase \u00fanicament posarem 2 quadres de text per al nom i la prov\u00edncia (amb 2 etiquetes) i 4 botons per a despla\u00e7ar-nos: al primer, a l'anterior, al seg\u00fcent i a l'\u00faltim. Heu de modificar els m\u00e8todes on estan les indicacions: El m\u00e8tode agafarComarques() ha de tornar la llista de les comarques. Per tant heu de fer una consulta HQL el m\u00e9s senzilla possible i posar tots els objectes de les comarques en la llista. El m\u00e8tode visComarca(int) servir\u00e0 per a visualitzar la comarca l'\u00edndex de la qual es passa per par\u00e0metre, assignant els valors als JtextField nomComarca i nomProvincia Implementa els 4 botons de despla\u00e7ament. Controla que no es puga eixir fora del rang deshabilitant els botons corresponents quan s'estiga en la primera o l'\u00faltima comarca. No t'oblides d'habilitar-los quan toque. Ac\u00ed tens \"l'esquelet\" del programa. Observa que la sessi\u00f3 est\u00e0 creada en la zona de declaracions de les propietats. Podr\u00edem haver-la creat en el m\u00e8tode afafarComarques() , que \u00e9s quan per mig d'una sent\u00e8ncia HQL agafarem totes les comarques i les posarem en un ArrayList . D'aquesta manera podr\u00edem tancar la sessi\u00f3 en el mateix m\u00e8tode agafarComarques() i no utilitzar m\u00e9s recursos dels necessaris. Hem optat per tenir la sessi\u00f3 oberta durant tota la durada del programa per fer-lo igual que en el seg\u00fcent exercici, en el qual s\u00ed que ens conv\u00e9 tenir la sessi\u00f3 oberta mentre dure el programa. Amb aquesta intenci\u00f3, el programa t\u00e9 deshabilitada l'opci\u00f3 de tancar la finestra ( defaultCloseOperation = JFrame.DO_NOTHING_ON_CLOSE ), i obligat\u00f2riament s'ha de tancarapretant al boto Eixir . Aprofitarem el m\u00e8tode associat al bot\u00f3 per a tancar la sessi\u00f3 ( s ) Observeu tamb\u00e9 que a banda de llistaComarques , l'arraylist on estan tots els objectes comarques, tamb\u00e9 tenim la propietat indActual , on guardem l'\u00edndex actual, \u00e9s a dir, l'\u00edndex de la comarca que s'ha d'estar visualitzant en aquest moment. Guarda-t'ho en el fitxer Kotlin Ex5_4_MantenimentComarques.kt import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.event.ActionEvent import java.awt.event.ActionListener import java.awt.EventQueue import javax.swing.JButton import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JPanel import javax.swing.JTextField import org.hibernate.Query import org.hibernate.Session import classes.Comarca import java.awt.event.WindowEvent import kotlin.system.exitProcess class FinestraMantenimentComarques : JFrame() { val etIni = JLabel(\"Manteniment de COMARQUES\") val etNom = JLabel(\"Nom comarca\") val etProv = JLabel(\"Nom prov\u00edncia\") val nomComarca = JTextField() val nomProvincia = JTextField() val primer = JButton(\"<<\") val anterior = JButton(\"<\") val seguent = JButton(\">\") val ultim = JButton(\">>\") val eixir = JButton(\"Eixir\") val pDalt = JPanel(FlowLayout()) val pCentre = JPanel(GridLayout(8, 0)) val pDades = JPanel(GridLayout(2, 2)) val pBotonsMov = JPanel(FlowLayout()) val pEixir = JPanel(FlowLayout()) val sessio = Configuration().configure().buildSessionFactory().openSession() var llistaComarques = ArrayList<Comarca>() var indActual = 0; init { defaultCloseOperation = JFrame.DO_NOTHING_ON_CLOSE setTitle(\"HIBERNATE: Manteniment Comarques\") setBounds(100, 100, 350, 400) setLayout(BorderLayout()) getContentPane().add(pCentre, BorderLayout.CENTER) getContentPane().add(JPanel(FlowLayout()), BorderLayout.WEST) getContentPane().add(JPanel(FlowLayout()), BorderLayout.EAST) getContentPane().add(pEixir, BorderLayout.SOUTH) pDalt.add(etIni) pCentre.add(pDalt) pDades.add(etNom) pDades.add(nomComarca) pDades.add(etProv) pDades.add(nomProvincia) pCentre.add(pDades) nomComarca.setEditable(false) nomProvincia.setEditable(false) pCentre.add(JPanel(FlowLayout())) pBotonsMov.add(primer) pBotonsMov.add(anterior) pBotonsMov.add(seguent) pBotonsMov.add(ultim) pCentre.add(pBotonsMov) pEixir.add(eixir) llistaComarques = agafarComarques() visComarca() primer.addActionListener() { primer() } anterior.addActionListener() { anterior() } seguent.addActionListener() { seguent() } ultim.addActionListener() { ultim() } eixir.addActionListener() { eixir()} } fun agafarComarques(): ArrayList<Comarca> { var llista = ArrayList<Comarca>() // ac\u00ed aniran les sent\u00e8ncies per a omplir (i retornar) la llista de comarques return llista } fun visComarca() { // M\u00e8tode per a visualitzar la comarca marcada per l'\u00edndex que ve com a par\u00e0metre controlBotons() } fun primer() { visComarca() } fun anterior() { visComarca() } fun seguent() { visComarca() } fun ultim() { visComarca() } fun controlBotons() { // M\u00e8tode per a habilitar/deshabilitar els botons anterior i seg\u00fcent, si s'est\u00e0 en la primera o \u00faltima comarca // No us oblideu d'habilitar-los quan toque } fun eixir() { //accions per a tancar i per a eixir exitProcess(0) } } fun main() { EventQueue.invokeLater { FinestraMantenimentComarques().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercicis"},{"location":"exercicis/#exercicis","text":"","title":"Exercicis"},{"location":"exercicis/#exercici-51","text":"Crea un projecte nou de l'estil de Java Enterprise anomenat Tema5_ PostgreSQL_Rutes_Anotacions . Inclou el driver JDBC de PostgreSQL. Has de fer el mapatge utilitzant anotacions (no els fitxer hbm.xml ) Fes el mapatge de les taules RUTA i PUNT , situades en la Base de Dades rutes a la qual pot accedir l'usuari rutes (contrasenya rutes ) i situada en el servidor de l'Institut ( 89.36.214.106 ). Guarda-les en un paquet anomenat classes . Veur\u00e0s que en el resultat apareixer\u00e0 tamb\u00e9 la classe PuntPK.java . \u00c9s a causa de que la clau principal de la taula PUNTS est\u00e0 formada per dos camps. \u00c9s la manera que t\u00e9 Hibernate de reflectir-ho. Tria tots els camps (que es convertiran en propietats). Canvia el nom d'alguna de les propietats Veur\u00e0s que en el resultat a m\u00e9s de les classes Ruta.java i Punt.java apareixer\u00e0 tamb\u00e9 la classe PuntPK.java . \u00c9s a causa de que la clau principal de la taula PUNTS est\u00e0 formada per dos camps. \u00c9s la manera que t\u00e9 Hibernate de reflectir-ho. Crea't el fitxer Kotlin VeureRutes.kt , que ser\u00e0 un programa senzill que visualitze les rutes, i el n\u00famero de punts, ordenades per nom de ruta, a m\u00e9s dels noms dels punts. Ha de ser per mig d'una consulta HQL (el m\u00e9s senzilla possible), i evidentment el programa ha de ser independent del n\u00famero de rutes existent en aquest moment a la Base de Dades. Intenta que no apareguen tots els warnings que apareixen per defecte. El m\u00e9s normal \u00e9s que t'aparega el seg\u00fcent error Repeated column in mapping for entity: classes.Punt column: num_r (should be mapped with insert=\"false\" update=\"false\") Per a corregir-ho has d'afegir a la classe Punt.java al final de tot, on apareix l'anotaci\u00f3 @JoinColumn , el que est\u00e0 en negreta a continuaci\u00f3. @ManyToOne @JoinColumn(name = \"num_r\", referencedColumnName = \"num_r\", nullable = false, insertable = false, updatable = false ) Una vegada corregit l'error, el resultat seria aquest: La Magdalena - 7 punts Primer Mol\u00ed Segon Mol\u00ed Camin\u00e0s Riu Sec Sant Roc Explanada La Magdalena Pelegrins de Les Useres - 6 punts Les Useres Les Torrocelles Lloma Bernat Xodos (Mol\u00ed) El Marinet Sant Joan Pujada a Penyagolosa - 5 punts Sant Joan Encreuament Barranc de la Pegunta El Corralico Penyagolosa","title":"Exercici 5.1"},{"location":"exercicis/#exercici-52","text":"Sobre el projecte de Tema5_Hibernate_PostgreSQL_geo_ad , on tenim el mapatge de les taules COMARCA , POBLACIO i INSTITUT , creeu-vos un paquet anomenat exercicis , on col\u00b7locareu les classes d'aquest exercici. Per a visualitzar les coses d'una forma un poc m\u00e9s agradable anem a utilitzar les llibreries gr\u00e0fiques Java AWT i Javax Swing . Amb aquestes llibreries incorporarem: JPanel i JScrollPane , per a contenir altres objectes (aquest \u00faltim amb botons de scroll si s\u00f3n necessaris). JLabel , per a etiquetes JText , per a quadres de text (on poder posar informaci\u00f3) JTextArea , \u00e9s un quadre de text, per\u00f2 m\u00e9s gran. Nosaltres l'utilitzarem per a visualitzar informaci\u00f3 extensa, i per tant el farem no editable. JButton , per a botons. Estar\u00e0 esperant a que l'apretem (ActionListener) Tot a\u00e7\u00f2 anir\u00e0 en un fitxer que anomenarem Ex5_2_VeurePoblesComarca.kt I vosaltres haureu de completar el m\u00e8tode VisualitzaCom(comarca: String) , per a que si no existeix la comarca, es diga que no existeix dins del JTextArea, i si existeix, que es vegen els seus pobles (si vols pots millorar-lo per a que es vegen en ordre alfab\u00e8tic). package exercicis import java.awt.EventQueue import java.awt.BorderLayout import java.awt.FlowLayout import javax.swing.JFrame import javax.swing.JPanel import javax.swing.JButton import javax.swing.JTextArea import javax.swing.JLabel import javax.swing.JTextField import java.awt.Color import javax.swing.JScrollPane class Finestra : JFrame() { val etiqueta = JLabel(\"Comarca:\") val etIni = JLabel(\"Introdueix la comarca:\") val com = JTextField(15) val consultar = JButton(\"Consultar\") val area = JTextArea() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"HIBERNATE: Visualitzar Comarques i Pobles\") setBounds(100, 100, 450, 300) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout ()) panell1.add(etIni) panell1.add(com) panell1.add(consultar) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout ()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) consultar.addActionListener() { etiqueta.setText(\"Comarca: \" + com.getText()) visualitzaCom(com.getText()) } } fun visualitzaCom(comarca: String){ // Instruccions per a llegir la comarca que arriba com a par\u00e0metre (s'ha de deixar en un objecte Comarca). // S'ha de cuidar que si no exiteix la comarca, en el JTextArea es pose que no existeix. // La manera d'anar introduint informaci\u00f3 en el JTextArea \u00e9s area.append(\"Linia que es vol introduir \") } } fun main() { EventQueue.invokeLater { Finestra().isVisible = true } } Aquest seria un exemple d'utilitzaci\u00f3:","title":"Exercici 5.2"},{"location":"exercicis/#exercici-53","text":"Anem a fer unes quantes millores a l'exemple anterior. Les millores seran les seg\u00fcents: (70%) Substitueix el quadre de text per un JComboBox , i elimina el bot\u00f3. Recorda que el component JCombBox funciona de la seg\u00fcnet manera: Per a obtenir l'element seleccionat utilitzarem el m\u00e8tode .getSelectedItem() Per a omplir el ComboBox haurem de fer una consulta pr\u00e8via amb els noms de les comarques (en principi amb els noms \u00e9s suficient). Podrem anar afegint elements al ComboBox amb el m\u00e8tode .addItem() (15%) Substitueix el JTextArea on mostrem els pobles de la comarca per un JList . Aquest component ser\u00e0 una llista, i podrem seleccionar cada element de la llista. El seu funcionament \u00e9s aix\u00ed: Per a anar omplint el JList , no \u00e9s tant senzill com el JComboBox . Ens fa falta un DefaultListModel , i construir el JList a partir d'ell. Posteriorment afegirem elements al DefaultListModel , i aix\u00f2 suposar\u00e0 que es veuran en el JList . Ja tenim creat aquest DefaultListModel, i es diu listModel Per a agafar els pobles de la comarca podem fer-ho de 2 maneres: carregant un objecte Comarca, i a partir d'ell obtenir els pobles fent una consulta per agafar els pobles de la comrca. En aquest cas podem tenir el problema que hi haja cometes simples en el nom de la comarca (p.e. Vall d'Albaida). A\u00e7\u00f2 faria que la consulta HQL falle (ja que la cometa simple \u00e9s el delimitador de les constants de text). Una manera de solucionar-lo \u00e9s utilitzar un par\u00e0metre, ja que d'aquesta manera no hi haur\u00e0 problema amb les cometes. Una altra manera de solucionar-lo \u00e9s posar dos cometes simples. Podem utilitzar el m\u00e8tode replace() de la classe String, substituint tota cometa simple per dues cometes simples. Si per exemple tenim el nom de la comarca en el String comarca , far\u00edem: comarca.replace(\"'\",\"''\") (15%) Quan se seleccione un element del JList , fes que es mostre baix de tot el n\u00famero d'Instituts del poble seleccionat Per a poder controlar si s'ha seleccionat un element del JList escoltarem ambb area.addListSelectionListener() (si el JList s'anomena area , clar). \u00c9s on posarem les accions per a mostrar el nombre d'Instituts del poble ( visualitzaInstituts(String) ) El nom del poble tamb\u00e9 pot dur cometes simples, per tant farem la mateixa consideraci\u00f3 d'abans. Ho solucionem amb un par\u00e0metre, o posant dues cometes simple substituint el nom del poble per: poble.replace(\"'\",\"''\") L'esquelet quedar\u00e0 ara d'aquesta manera. Guardeu-lo en un fitxer anomenat Ex5_3_VeurePoblesComarca_Combobox.kt : import java.awt.EventQueue import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.Color import javax.swing.JFrame import javax.swing.JPanel import javax.swing.JLabel import javax.swing.JTextField import javax.swing.JScrollPane import javax.swing.JComboBox import javax.swing.DefaultListModel import javax.swing.JList import classes.Comarca import classes.Poblacio class FinestraComboBox : JFrame() { val etiqueta = JLabel(\"Comarca:\") val etIni = JLabel(\"Introdueix la comarca:\") val com = JComboBox<String>() val listModel = DefaultListModel<String>() val area = JList(listModel) val peu = JTextField() val sessio = Configuration().configure().buildSessionFactory().openSession() init { defaultCloseOperation = JFrame.EXIT_ON_CLOSE setTitle(\"HIBERNATE: Visualitzar Comarques i Pobles amb ComboBox\") setBounds(100, 100, 550, 400) setLayout(BorderLayout()) val panell1 = JPanel(FlowLayout()) panell1.add(etIni) panell1.add(com) getContentPane().add(panell1, BorderLayout.NORTH) val panell2 = JPanel(BorderLayout()) panell2.add(etiqueta, BorderLayout.NORTH) area.setForeground(Color.blue) val scroll = JScrollPane(area) panell2.add(scroll, BorderLayout.CENTER) getContentPane().add(panell2, BorderLayout.CENTER) getContentPane().add(peu, BorderLayout.SOUTH) agafarComarques() com.addActionListener() { visualitzaCom(com.getSelectedItem().toString()) } area.addListSelectionListener() { if (!area.isSelectionEmpty()) visualitzaInstituts(area.getSelectedValue()) else peu.setText(\"\") } } fun agafarComarques() { // Instruccions per a posar en el ComboBox el nom de totes les comarques, millor si \u00e9s per ordre alfab\u00e8tic } fun visualitzaCom(comarca: String) { // Instruccions per a llegir la comarca que arriba com a par\u00e0metre (s'ha de deixar en un objecte Comarca). // S'ha de cuidar que si no exiteix la comarca, en el JList es pose que no existeix. // La manera d'anar introduint informaci\u00f3 en el JList \u00e9s a trav\u00e9s del DefaultListModel: // listModel.addElement(\"Linia que es vol introduir \") // Per a esborrar els element del JList: listModel.clear() // Es pot fer carregant un objecte, o per mig de consulta, per\u00f2 en aquest cas podem tenir problemes amb ' // Una manera de solucionar el problema de la cometa simple \u00e9s utilitzar comarca.replaceAll(\"'\",\"''\"). // Una altra \u00e9s utilitzar par\u00e0metres } fun visualitzaInstituts(poble: String) { // Instruccions per a mostrar el n\u00famero d'Instituts del poble seleccionat // La millor manera \u00e9s per mig d'una consulta. Podem tenir problemes amb la cometa simple // Una manera de solucionar el problema de la cometa simple \u00e9s utilitzar poble.replaceAll(\"'\",\"''\"). // Una altra \u00e9s utilitzar par\u00e0metres } } fun main() { EventQueue.invokeLater { FinestraComboBox().isVisible = true } } Aquest seria un exemple d'execuci\u00f3:","title":"Exercici 5.3"},{"location":"exercicis/#exercici-54","text":"Anem a intentar un programa per al manteniment de les comarques (no intentarem mantenir els pobles de la comarca, \u00fanicament el nom i la prov\u00edncia de la comarca). Ha d'estar en el paquet Exercicis del projecte Tema5_Hibernate_PostgreSQL_geo_ad. En una primera fase \u00fanicament posarem 2 quadres de text per al nom i la prov\u00edncia (amb 2 etiquetes) i 4 botons per a despla\u00e7ar-nos: al primer, a l'anterior, al seg\u00fcent i a l'\u00faltim. Heu de modificar els m\u00e8todes on estan les indicacions: El m\u00e8tode agafarComarques() ha de tornar la llista de les comarques. Per tant heu de fer una consulta HQL el m\u00e9s senzilla possible i posar tots els objectes de les comarques en la llista. El m\u00e8tode visComarca(int) servir\u00e0 per a visualitzar la comarca l'\u00edndex de la qual es passa per par\u00e0metre, assignant els valors als JtextField nomComarca i nomProvincia Implementa els 4 botons de despla\u00e7ament. Controla que no es puga eixir fora del rang deshabilitant els botons corresponents quan s'estiga en la primera o l'\u00faltima comarca. No t'oblides d'habilitar-los quan toque. Ac\u00ed tens \"l'esquelet\" del programa. Observa que la sessi\u00f3 est\u00e0 creada en la zona de declaracions de les propietats. Podr\u00edem haver-la creat en el m\u00e8tode afafarComarques() , que \u00e9s quan per mig d'una sent\u00e8ncia HQL agafarem totes les comarques i les posarem en un ArrayList . D'aquesta manera podr\u00edem tancar la sessi\u00f3 en el mateix m\u00e8tode agafarComarques() i no utilitzar m\u00e9s recursos dels necessaris. Hem optat per tenir la sessi\u00f3 oberta durant tota la durada del programa per fer-lo igual que en el seg\u00fcent exercici, en el qual s\u00ed que ens conv\u00e9 tenir la sessi\u00f3 oberta mentre dure el programa. Amb aquesta intenci\u00f3, el programa t\u00e9 deshabilitada l'opci\u00f3 de tancar la finestra ( defaultCloseOperation = JFrame.DO_NOTHING_ON_CLOSE ), i obligat\u00f2riament s'ha de tancarapretant al boto Eixir . Aprofitarem el m\u00e8tode associat al bot\u00f3 per a tancar la sessi\u00f3 ( s ) Observeu tamb\u00e9 que a banda de llistaComarques , l'arraylist on estan tots els objectes comarques, tamb\u00e9 tenim la propietat indActual , on guardem l'\u00edndex actual, \u00e9s a dir, l'\u00edndex de la comarca que s'ha d'estar visualitzant en aquest moment. Guarda-t'ho en el fitxer Kotlin Ex5_4_MantenimentComarques.kt import java.awt.BorderLayout import java.awt.FlowLayout import java.awt.GridLayout import java.awt.event.ActionEvent import java.awt.event.ActionListener import java.awt.EventQueue import javax.swing.JButton import javax.swing.JFrame import javax.swing.JLabel import javax.swing.JPanel import javax.swing.JTextField import org.hibernate.Query import org.hibernate.Session import classes.Comarca import java.awt.event.WindowEvent import kotlin.system.exitProcess class FinestraMantenimentComarques : JFrame() { val etIni = JLabel(\"Manteniment de COMARQUES\") val etNom = JLabel(\"Nom comarca\") val etProv = JLabel(\"Nom prov\u00edncia\") val nomComarca = JTextField() val nomProvincia = JTextField() val primer = JButton(\"<<\") val anterior = JButton(\"<\") val seguent = JButton(\">\") val ultim = JButton(\">>\") val eixir = JButton(\"Eixir\") val pDalt = JPanel(FlowLayout()) val pCentre = JPanel(GridLayout(8, 0)) val pDades = JPanel(GridLayout(2, 2)) val pBotonsMov = JPanel(FlowLayout()) val pEixir = JPanel(FlowLayout()) val sessio = Configuration().configure().buildSessionFactory().openSession() var llistaComarques = ArrayList<Comarca>() var indActual = 0; init { defaultCloseOperation = JFrame.DO_NOTHING_ON_CLOSE setTitle(\"HIBERNATE: Manteniment Comarques\") setBounds(100, 100, 350, 400) setLayout(BorderLayout()) getContentPane().add(pCentre, BorderLayout.CENTER) getContentPane().add(JPanel(FlowLayout()), BorderLayout.WEST) getContentPane().add(JPanel(FlowLayout()), BorderLayout.EAST) getContentPane().add(pEixir, BorderLayout.SOUTH) pDalt.add(etIni) pCentre.add(pDalt) pDades.add(etNom) pDades.add(nomComarca) pDades.add(etProv) pDades.add(nomProvincia) pCentre.add(pDades) nomComarca.setEditable(false) nomProvincia.setEditable(false) pCentre.add(JPanel(FlowLayout())) pBotonsMov.add(primer) pBotonsMov.add(anterior) pBotonsMov.add(seguent) pBotonsMov.add(ultim) pCentre.add(pBotonsMov) pEixir.add(eixir) llistaComarques = agafarComarques() visComarca() primer.addActionListener() { primer() } anterior.addActionListener() { anterior() } seguent.addActionListener() { seguent() } ultim.addActionListener() { ultim() } eixir.addActionListener() { eixir()} } fun agafarComarques(): ArrayList<Comarca> { var llista = ArrayList<Comarca>() // ac\u00ed aniran les sent\u00e8ncies per a omplir (i retornar) la llista de comarques return llista } fun visComarca() { // M\u00e8tode per a visualitzar la comarca marcada per l'\u00edndex que ve com a par\u00e0metre controlBotons() } fun primer() { visComarca() } fun anterior() { visComarca() } fun seguent() { visComarca() } fun ultim() { visComarca() } fun controlBotons() { // M\u00e8tode per a habilitar/deshabilitar els botons anterior i seg\u00fcent, si s'est\u00e0 en la primera o \u00faltima comarca // No us oblideu d'habilitar-los quan toque } fun eixir() { //accions per a tancar i per a eixir exitProcess(0) } } fun main() { EventQueue.invokeLater { FinestraMantenimentComarques().isVisible = true } } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici 5.4"}]}